<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jinko the Snokl</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sj602.github.io/"/>
  <updated>2020-04-13T04:28:20.948Z</updated>
  <id>https://sj602.github.io/</id>
  
  <author>
    <name>Jin Seon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[책] 재능은 어떻게 단련되는가</title>
    <link href="https://sj602.github.io/2020/04/13/%EC%B1%85-%EC%9E%AC%EB%8A%A5%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8B%A8%EB%A0%A8%EB%90%98%EB%8A%94%EA%B0%80/"/>
    <id>https://sj602.github.io/2020/04/13/%EC%B1%85-%EC%9E%AC%EB%8A%A5%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8B%A8%EB%A0%A8%EB%90%98%EB%8A%94%EA%B0%80/</id>
    <published>2020-04-13T04:28:20.000Z</published>
    <updated>2020-04-13T04:28:20.948Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.yes24.com/goods/4121680/800x0" alt="재능은 어떻게 단련되는가"></p><ul><li><p>신중하게 계획된 연습은 특별히 개선해야 할 필요가 있는 특정 부분을 찾아내 그 부분만 집중적으로 훈련하는 것이다.</p></li><li><p>노엘 터치(미시간 경영대학원 교수) - Comfort Zone, Learning Zone, Panic Zone<br>Comfort Zone에서는 실력이 늘지 않고 Panic Zone에서는 너무 어려워 접근 방법조차 알지 못 한다.<br>Leaning Zone을 제대로 파악하는게 중요!(칙센트미하이가 말한 몰입의 영역과 비슷하다)</p></li><li><p>바이올린 협주곡을 연주할 때 제대로 연주했는지 아닌지 당신이 어떻게 알겠는가?</p></li><li><p>피드백을 받을 수 있는 교사,코치,멘토의 존재가 반드시 필요하다.</p></li><li><p>사람들은 대개 특정 활동을 계속해서 반복하는 것을 두고 연습이라고 하지만 그런 연습은 그다지 효과적이지 않다.<br>무심코 하는 연습보단 오래 하기 힘들 정도의 집중이 필요한 연습을 해야한다.<br>뛰어난 운동선수들조차 연습 시간을 제한하는 것이 집중력을 유지하는 비결이라고 밝혔다.</p></li><li><p>잘하는 법을 이미 알면서 무언가를 하는 것은 즐겁다. 하지만 신중하게 계획된 연습은 그와 정반대의 것을 추구한다(지루하다). 연습이 끝난 다음에는 타인의 피드백을 통해 아직 미흡한 부분이 어디인지 정확히 찾아내야하고 가장 고통스럽고 힘든 부분을 반복해야한다. 우리를 위대함의 길로 인도하는 길이 쉽고 재밌다면 누가 그 길을 마다하겠는가? 사람들이 대부분 그런 연습을 하지 않기 때문에 당신은 그만큼 차별화된 존재가 된다.</p></li><li><p>신중하게 계획된 연습만 하는 것이 재능을 단련시키는 데에 전부인가?<br>아니다. 개인의 신체적 변화나, 주변 환경, 그 연습이 얼마나 훌륭하게 설게되었는가 등을 배제하지 않을 수 없다.</p></li><li><p>연습은 반사적으로 잘하는 것이 아니다. 흔히 사람들은 위대한 성과자들이 아주 오랫동안 연습해 왔고 같은 일을 수없이 반복해 왔으니까 그 일을 반사적으로 할 수 있다고 생각한다. 하지만 사실 그들이 연습을 통해 습득한 것은 반사적으로 하지 않는 능력이다. 그들은 자동장치가 작동해 발전을 멈춘 상태가 되지 않도록 스스로 노력한다. 편안함과 거리가 먼 일을 지속적으로 수행한다. 그것이 바로 그들이 자기 분야에서 오랫동안 최정상의 자리를 지키는 방법이다.</p></li><li><p>연습은 다른 사람들보다 더 많이 인식하고, 더 많이 배우고, 더 많이 기억할 수 있게 해준다. 그리고 그것이 결국 개인의 한계를 넘도록 해준다. 신중하게 계획된 연습으로 여러 해를 보내면 실제로 몸과 뇌가 변한다. 이것이 위대한 성과자가 우리와 근본적으로 다른 존재처럼 보이게 만드는 이유이다.-&gt;’미엘린’이라는 물질이 생성된다.</p></li></ul><h3 id="실생활에서의-연습-방법"><a href="#실생활에서의-연습-방법" class="headerlink" title="실생활에서의 연습 방법"></a>실생활에서의 연습 방법</h3><h4 id="음악-모델"><a href="#음악-모델" class="headerlink" title="음악 모델"></a>음악 모델</h4><p>프레젠테이션:준비한 발표문을 분석하고 각 부분마다 가장 강력하게 전달해야 할 핵심 느낌을 결정하고 반복적으로 연습하되 녹화한 영상을 보면서 피드백을 받아 그 느낌을 더 효과적으로 낼 수 있도록 연습.</p><h4 id="체스-모델"><a href="#체스-모델" class="headerlink" title="체스 모델"></a>체스 모델</h4><p>수 많은 케이스 스터디를 하면서 나라면 어떻게 할 것인지 연습.</p><h4 id="스포츠-모델"><a href="#스포츠-모델" class="headerlink" title="스포츠 모델"></a>스포츠 모델</h4><p>스포츠 선수들이 기본적인 체력에 집중하는 것처럼 일상 생활에서도 해당하는 능력이 요구하는 기초적인 부분에 있어 녹슬지 않게 주기적으로 연습(기초 수학/회계/과학 등 예전에 이미 봤던 교재를 보며 기본적인 기술을 다시 살펴보기)<br>메타인지를 통해 자신이 무엇을 알고 모르는지 인식</p><ul><li>사후 평가를 통해 무엇을 못 했고 잘 했는지, 개선되어야할 부분은 무엇인지 평가.</li><li>큰 그림 그리기 - 하버드 경영대학원의 마이클 포터 교수는 기업에 자문을 할 때 해당 기업과 그 관련 산업을 철저히 연구하면서 준비한다. 도서관에서 20시간 정도 집중해서 파고들면 그 분야에 대해 CEO보다 훨씬 많은 것을 알게 된다고 한다. 이 때 중요한 것이 큰 그림을 그리면서 해당 분야가 하나의 시스템으로 어떻게 작동하는지 사고 모형을 구축하는 것.</li></ul><h3 id="기업에서의-적용-사례"><a href="#기업에서의-적용-사례" class="headerlink" title="기업에서의 적용 사례"></a>기업에서의 적용 사례</h3><ul><li><p>직원은 일만 하는 것이 아니라 능력을 키우고 성장한다는 사실을 이해</p></li><li><p>최고의 기업이 직원에게 업무를 배분하는 방식은 운동 코치가 선수에게, 음악 교사가 제자에게 연습할 내용을 정해 주는 방식과 매우 흡사하다. 즉 현재 능력의 범위를 넘어설 수 있도록 가장 중요한 기술을 단련시킨다,</p></li><li><p>권위가 아닌 영감을 통한 인재 양성이 가장 효과적임을 이해</p></li><li><p>신중하게 계획된 연습은 굉장히 힘든 과정이기 때문에 강력한 동기부여 없이는 누구도 오래 버티지 못 한다. 저성과자에 대해 해고나 강등 등 부정적인 유인으로 관리하는 것은 비효율적이다.</p></li><li><p>캘리포니아 주립대학의 제임스 코프먼은 혁신은 모두 동일한 발달 과정의 연속선상에 있으며 참신하고 개인적으로 유의미한 해석(mini-c)에서 출발해 개인들 상호간에 의미있는 것으로 인정하는 단계(little-c)를 지나 훌륭한 창의적 성과(big-c)로 나아가는 궤도로 따른다고 한다. 이는 창조성이라는 부분도 타고나는 것이 아닌 신중하게 계획된 연습을 통해서 계발할 수 있다는 걸 뜻한다. 창조는 우리가 흔히 생각하는 것보다 훨씬 더 의시적인 노력에 가깝고 어떤 분야에서 최고가 되기를 갈망하고, 그러기 위해 열심히 노력하며, 혁신을 지향하는 것으로 이루어진다.</p></li><li><p>창의적인 사람들은 자기 자신(이 문제를 해결하는 것이 나에게 이익이 될까?)이 아니라 과업(이 문제를 어떻게 하면 해결할 수 있을까?)에 초점을 맞추었다.</p></li><li><p>열정은 타고나는 것이 아니라 개발이 가능하다. 어느 분야이건 세계적 수준의 대가들에게는 더 나아지려는 열정이 있지만, 그들 대다수도 처음부터 그랬던 것은 아니다. 어릴때부터 연습을 시작하는 음악이나 스포츠 등의 분야에서 아이들에게는 일정량의 강요가 불가피하다는 사실이 그것이다. 관련 지식을 습득하는 데만 몇 년이 걸리는 특정 분야에서 장차 최고의 자리에 서게 될 사람들도 젊은 시절엔 자기 길을 분명하게 정하지 못한 경우가 흔했다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.yes24.com/goods/4121680/800x0&quot; alt=&quot;재능은 어떻게 단련되는가&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;신중하게 계획된 연습은 특별히 개선해야 할 필요가 있는 특정 부분을 찾아내 그 부분
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[컴퓨터구성] 3주차</title>
    <link href="https://sj602.github.io/2020/04/07/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1-3%EC%A3%BC%EC%B0%A8/"/>
    <id>https://sj602.github.io/2020/04/07/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1-3%EC%A3%BC%EC%B0%A8/</id>
    <published>2020-04-07T12:09:15.000Z</published>
    <updated>2020-04-07T12:09:15.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="조합논리회로-Combinational-Circuits"><a href="#조합논리회로-Combinational-Circuits" class="headerlink" title="조합논리회로 (Combinational Circuits)"></a>조합논리회로 (Combinational Circuits)</h1><ul><li>입력에 의해 출력이 결정</li></ul><h2 id="Half-Adder"><a href="#Half-Adder" class="headerlink" title="Half Adder"></a>Half Adder</h2><ul><li>2개의 비트를 산술연산<br>S = x xor y = x’y + xy’<br>C = xy</li><li>진리표<br><img src="/image/half-adder-truth-table.png" alt=""></li></ul><h2 id="Full-Adder"><a href="#Full-Adder" class="headerlink" title="Full Adder"></a>Full Adder</h2><ul><li><p>3개의 비트를 산술연산<br>S = x xor y xor z = x’y’z + x’yz’ + xy’z’ + xyz<br>C = xy + xz + yz</p></li><li><p>진리표<br><img src="/image/full-adder-truth-table.png" alt=""></p></li></ul><h1 id="순서논리회로-Sequential-Circuits"><a href="#순서논리회로-Sequential-Circuits" class="headerlink" title="순서논리회로 (Sequential Circuits)"></a>순서논리회로 (Sequential Circuits)</h1><ul><li>피드백(Feedback)을 가진 조합회로로 구성</li><li>입력 값과 현재 기억 상태에 따라 출력이 결정</li></ul><h2 id="Flip-Flop"><a href="#Flip-Flop" class="headerlink" title="Flip-Flop"></a>Flip-Flop</h2><ul><li>1비트를 기억하는 소자</li><li>clock pulse generator에 의해 synchronization이 일어남</li><li>래치라고도 함</li></ul><h3 id="SR-Flip-Flop"><a href="#SR-Flip-Flop" class="headerlink" title="SR Flip-Flop"></a>SR Flip-Flop</h3><ul><li>R(Reset)과 S(Set) 두 입력을 받아서 Q(현재 상태)와 Q’(다음 상태)의 2가지 출력을 가진다</li><li>진리표<br><img src="/image/rs-flip-flop.png" alt=""></li><li>특성표<br><img src="/image/rs-flip-flop2.png" alt=""></li></ul><h3 id="D-Flip-Flop"><a href="#D-Flip-Flop" class="headerlink" title="D Flip-Flop"></a>D Flip-Flop</h3><ul><li>특성표<br><img src="/image/d-flip-flop.png" alt=""></li></ul><h3 id="JK-Flip-Flop"><a href="#JK-Flip-Flop" class="headerlink" title="JK Flip-Flop"></a>JK Flip-Flop</h3><ul><li>RS 플립플롭보다 많이 쓰이는 플립플롭(RS플립플롭의 문제점 보완)</li><li>진리표<br><img src="/image/jk-flip-flop.png" alt=""></li><li>특성표<br><img src="/image/jk-flip-flop2.png" alt=""></li></ul><h4 id="Level-triggering-vs-Edge-triggering"><a href="#Level-triggering-vs-Edge-triggering" class="headerlink" title="Level-triggering vs Edge-triggering"></a>Level-triggering vs Edge-triggering</h4><ul><li>클락이 올라갈 때 positie</li><li>클락이 내려갈 때 negative</li></ul><h2 id="Excitation-table"><a href="#Excitation-table" class="headerlink" title="Excitation table"></a>Excitation table</h2><ul><li>플립플롭에서 현 상태와 다음 상태를 알 때 플립플롭에 어떤 입력을 넣어야 하는가를 나타냄</li><li>RS 플립플롭의 excitation table<br><img src="/image/rs-flip-flop-excitation-table.png" alt=""></li><li>JK 플립플롭의 excitation table<br><img src="/image/jk-flip-flop-excitation-table.png" alt=""></li><li>D 플립플롭의 excitation table<br><img src="/image/d-flip-flop-excitation-table.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;조합논리회로-Combinational-Circuits&quot;&gt;&lt;a href=&quot;#조합논리회로-Combinational-Circuits&quot; class=&quot;headerlink&quot; title=&quot;조합논리회로 (Combinational Circuits)&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[알고리즘] 프로그래머스 불량 사용자 파이썬 풀이</title>
    <link href="https://sj602.github.io/2020/04/05/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%88%EB%9F%89-%EC%82%AC%EC%9A%A9%EC%9E%90/"/>
    <id>https://sj602.github.io/2020/04/05/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%88%EB%9F%89-%EC%82%AC%EC%9A%A9%EC%9E%90/</id>
    <published>2020-04-05T07:29:50.000Z</published>
    <updated>2020-04-05T07:36:49.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h1><p><a href="https://programmers.co.kr/learn/courses/30/lessons/64064" target="_blank" rel="noopener">https://programmers.co.kr/learn/courses/30/lessons/64064</a></p><h1 id="풀이-방법"><a href="#풀이-방법" class="headerlink" title="풀이 방법"></a>풀이 방법</h1><p>먼저 banned_id를 기준으로 user_id를 하나씩 돌면서</p><ul><li>서로 글자수가 같고,</li><li><code>*</code>를 제외한 모든 글자가 서로 똑같은 user_id를 찾는다.</li></ul><p>그걸 <code>candidates</code> 리스트로 넘겨준다. 그러면 각 banned_id가 가질 수 있는 후보 리스트가 완성이 된다.</p><p>이제 <code>candidates</code>의 각 리스트를 돌면서 <code>dfs</code>로 모든 경우의 수를 따져주면 된다.</p><p><code>dfs</code>의 파라미터로</p><p>앞으로 탐색해야할 banned_id에 해당하는 user_id 리스트 <code>candidates</code>,</p><p>선택하지 않은 user_id 리스트 <code>users</code>,</p><p>이번 경우의 수가 담긴 result,</p><p>최종 결과가 들어갈 세트 <code>results</code>가 들어간다.</p><p>중간에 기존에 있던 레퍼런스들이 아닌 <code>deepcopy</code>를 이용해 기존 내용이 똑같이 담긴 새로운 리스트들이 생성되는데</p><p>그렇게 하지 않으면 재귀를 이용한 백트랙킹이 안되기 때문이다.</p><p>이해가 되지 않는다면 예를 들어보자.</p><p>입력값이 <code>user_id: [&quot;frodo&quot;, &quot;fradi&quot;, &quot;crodo&quot;, &quot;abc123&quot;, &quot;frodoc&quot;], banned_id: [&quot;*rodo&quot;, &quot;*rodo&quot;, &quot;******&quot;]</code>로 주어졌을 때 (입출력 예시2번)</p><p>candidates는 <code>[[&#39;frodo&#39;, &#39;crodo&#39;], [&#39;frodo&#39;, &#39;crodo&#39;], [&#39;abc123&#39;, &#39;frodoc&#39;]]</code> 로 나오게 된다.</p><p><code>[&#39;frodo&#39;, &#39;crodo&#39;]</code> 이 리스트가 2번 들어간 이유는 <code>banned_id</code>에 <code>&quot;*rodo&quot;</code> 이 조건이 2번 들어가있기 때문에 중복처리를 해주지 않고 들어가 있기 때문이다.</p><p>이제 <code>dfs</code> 함수로 들어가 <code>[&#39;frodo&#39;, &#39;crodo&#39;]</code> 이 아이템부터 경우의 수를 따져본다.</p><p>여기서 <code>frodo</code>를 선택한다면 다음 아이템에선 <code>frodo</code> 또는 <code>crodo</code>,</p><p>다음 아이템에선 <code>abc123</code> 또는 <code>frodoc</code>을 선택할 수 있다.</p><p>반대로 여기서 <code>crodo</code>를 선택한다면 똑같이 다음 아이템에선 <code>frodo</code> 또는 <code>crodo</code>,</p><p>다음 아이템에선 <code>abc123</code> 또는 <code>frodoc</code>을 선택할 수 있다.</p><p>결국 results값으로</p><p><code>[&#39;frodo&#39;, &#39;crodo&#39;, &#39;abc123&#39;]</code></p><p><code>[&#39;crodo&#39;, &#39;frodo&#39;, &#39;abc123&#39;]</code></p><p><code>[&#39;frodo&#39;, &#39;crodo&#39;, &#39;frodoc&#39;]</code></p><p><code>[&#39;frodo&#39;, &#39;crodo&#39;, &#39;frodoc&#39;]</code></p><p>이 4 가지 경우가 나올 수 있다.</p><p>하지만 문제 조건에 나와있듯이 원소의 순서에 상관없이 리스트에 담긴 원소가 같다면 동일한 경우로 생각하기 때문에</p><p>중복된 부분을 제거해주어야 한다.</p><p><code>세트</code>를 통해서 중복을 없앨 수 있고 그러기 위해선 중복된 케이스가 같은 원소여야 한다.</p><p>하지만</p><p><code>[&#39;frodo&#39;, &#39;crodo&#39;, &#39;abc123&#39;]</code></p><p><code>[&#39;crodo&#39;, &#39;frodo&#39;, &#39;abc123&#39;]</code></p><p>이 케이스를 <code>세트</code>에 넣어준다면 다른 원소로 인식이 될 것이다. (애초에 <code>리스트</code>는 <code>세트</code>에 삽입하지 못 하지만..)</p><p>같은 원소로 인식하기 위해서 <code>dfs</code>의 base case로 해당 스택까지 트랙킹해온 result배열을 정렬해 준다.</p><p>그리고 <code>리스트</code>를 <code>튜플</code>에 넣는다면 hashable하지 않기 때문에 <code>리스트</code>를 <code>튜플</code>로 바꿔준다. (원소의 순서 고정)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#39;frodo&#39;, &#39;crodo&#39;, &#39;abc123&#39;] &#x3D;&gt; &#123;&#39;crodo&#39;, &#39;frodo&#39;, &#39;abc123&#39;&#125;로 변한됨</span><br></pre></td></tr></table></figure><p>마지막으로 <code>세트</code>로 선언된 <code>results</code>에 넣어주면</p><p><code>[&#39;frodo&#39;, &#39;crodo&#39;, &#39;abc123&#39;]</code></p><p><code>[&#39;crodo&#39;, &#39;frodo&#39;, &#39;abc123&#39;]</code></p><p>와 같은 케이스는 중복처리 되어 하나만 남게된다.</p><p>최종적으로 <code>results</code>가 가지고 있는 각 경우의 집합?의 갯수를 세어주면 된다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(candidates, users, result, results)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">    results.add(tuple(sorted(result)))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  new_candidates = copy.deepcopy(candidates)</span><br><span class="line">  curr = new_candidates.pop()</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> curr:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">in</span> users:</span><br><span class="line">      new_result = copy.deepcopy(result)</span><br><span class="line">      new_result.append(item)</span><br><span class="line">      new_users = copy.deepcopy(users)</span><br><span class="line">      new_users.remove(item)</span><br><span class="line"></span><br><span class="line">      dfs(new_candidates, new_users, new_result, results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(user_id, banned_id)</span>:</span></span><br><span class="line">  candidates = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> bid <span class="keyword">in</span> banned_id:</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> user_id:</span><br><span class="line">      found=<span class="literal">True</span></span><br><span class="line">      <span class="keyword">if</span> len(bid) != len(uid):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bid)):</span><br><span class="line">        <span class="keyword">if</span> bid[i] == <span class="string">"*"</span> <span class="keyword">or</span> bid[i] == uid[i]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            found=<span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> found:</span><br><span class="line">        temp.append(uid)</span><br><span class="line"></span><br><span class="line">    candidates.append(temp)</span><br><span class="line"></span><br><span class="line">  results = set()</span><br><span class="line">  dfs(candidates, user_id, [], results)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len(results)</span><br></pre></td></tr></table></figure><h1 id="배운-점"><a href="#배운-점" class="headerlink" title="배운 점"></a>배운 점</h1><p>파이썬의 함수 인자 전달 방식은 <code>call-by-object-reference</code>이다.</p><p>mutable한 타입은 <code>call-by-value</code>로,</p><p>immutable한 타입은 <code>call-by-reference</code>로 함수의 인자가 전달된다.</p><p>나는 다른 언어를 쓰던 습관이 남아있어 <code>call-by-value</code>인 줄 알고</p><p>dfs를 할 때 인자로 넘겨준 값이 예상한 값과 다른 값이 나왔다.</p><p><code>copy</code> 모듈을 이용해 <code>deepcopy</code>를 해서 레퍼런스가 아닌 새로운 객체가 넘겨지도록 바꾸어주었다.</p><p>++ 이러한 방식이 <code>백트랙킹</code> 임을 깨닫게 되었다!!!</p><p>++ <code>세트</code>에 <code>리스트</code>를 넣을때는 <code>튜플</code>로 변환해서 넣어줄 수 있다는 것을 알았다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제-링크&quot;&gt;&lt;a href=&quot;#문제-링크&quot; class=&quot;headerlink&quot; title=&quot;문제 링크&quot;&gt;&lt;/a&gt;문제 링크&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lesson
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[알고리즘] 프로그래머스 튜플 파이썬 풀이</title>
    <link href="https://sj602.github.io/2020/04/04/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8A%9C%ED%94%8C/"/>
    <id>https://sj602.github.io/2020/04/04/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8A%9C%ED%94%8C/</id>
    <published>2020-04-03T15:13:46.000Z</published>
    <updated>2020-04-03T15:14:29.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h1><ul><li><a href="https://programmers.co.kr/learn/courses/30/lessons/64065" target="_blank" rel="noopener">https://programmers.co.kr/learn/courses/30/lessons/64065</a></li></ul><h1 id="풀이-방법"><a href="#풀이-방법" class="headerlink" title="풀이 방법"></a>풀이 방법</h1><p>문자열 파싱을 할 줄 안다면 쉬운 문제이다.</p><p>먼저 문제에 주어진 입출력 예시를 보면,</p><p>각 <code>{}</code>로 나뉘어진 집합별로 나눈 다음에 집합 안의 숫자들을</p><p>배열에 순서를 지켜가면서 넣어주면 된다.</p><p>이 때, 각 집합을 길이 오름차순으로 나열한 다음 중복을 체크해주어야 한다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(s)</span>:</span></span><br><span class="line">    answer = []</span><br><span class="line">    string = s[<span class="number">1</span>:len(s)<span class="number">-1</span>].replace(<span class="string">'&#125;,'</span>, <span class="string">'&#125;-'</span>).split(<span class="string">"-"</span>)</span><br><span class="line">    string = sorted([item[<span class="number">1</span>:len(item)<span class="number">-1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> string], key=<span class="keyword">lambda</span> item: len(item))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> item.split(<span class="string">","</span>):</span><br><span class="line">            <span class="keyword">if</span> int(digit) <span class="keyword">not</span> <span class="keyword">in</span> answer:</span><br><span class="line">                answer.append(int(digit))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제-링크&quot;&gt;&lt;a href=&quot;#문제-링크&quot; class=&quot;headerlink&quot; title=&quot;문제 링크&quot;&gt;&lt;/a&gt;문제 링크&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/
      
    
    </summary>
    
    
      <category term="알고리즘" scheme="https://sj602.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
    
      <category term="알고리즘" scheme="https://sj602.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="프로그래머스" scheme="https://sj602.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="파이썬" scheme="https://sj602.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
      <category term="python" scheme="https://sj602.github.io/tags/python/"/>
    
      <category term="2019 카카오 개발자 겨울 인턴십" scheme="https://sj602.github.io/tags/2019-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B2%A8%EC%9A%B8-%EC%9D%B8%ED%84%B4%EC%8B%AD/"/>
    
  </entry>
  
  <entry>
    <title>[운영체제] 3주차</title>
    <link href="https://sj602.github.io/2020/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-3%EC%A3%BC%EC%B0%A8/"/>
    <id>https://sj602.github.io/2020/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-3%EC%A3%BC%EC%B0%A8/</id>
    <published>2020-04-03T12:48:49.000Z</published>
    <updated>2020-04-03T12:48:49.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Modern-Computer-Systems"><a href="#Modern-Computer-Systems" class="headerlink" title="Modern Computer Systems"></a>Modern Computer Systems</h1><ul><li>Consists of CPUs, Main Memory, other devices</li><li>Connected by a bus to access Main Memory</li><li>CPU and devices(controllers) execute simultaneosly and compete for shared memory</li><li>Memory controller unit(MMU) ensures these orders</li></ul><h1 id="Basic-Understanding"><a href="#Basic-Understanding" class="headerlink" title="Basic Understanding"></a>Basic Understanding</h1><ul><li>OS(image) is stored in HDD(SSD)</li><li>When power is off, MM is empty(volatile) =&gt; so, when power is on, CPU can do nothing</li><li>Thus, to start computer, OS image must be loaded into MM</li></ul><h1 id="Bootstrap-program"><a href="#Bootstrap-program" class="headerlink" title="Bootstrap program"></a>Bootstrap program</h1><ul><li>하드웨어 제조사에서 개발</li><li>First program to run when power is on</li><li>Stored in Boot-ROM</li><li>Initializes computer system hardware (OS가 초기화 하지 않는 이유? 하드웨어는 제조사별로 다양하기 때문에 OS가 일괄적으로 초기화 불가능)</li><li>Loads OS from HDD(SSD) to first location of MM (addr = 0 or predefined)</li></ul><h1 id="What-does-CPU-do"><a href="#What-does-CPU-do" class="headerlink" title="What does CPU do?"></a>What does CPU do?</h1><ul><li>Fetch Instr.=&gt; Decode =&gt; Fetch Data =&gt; Execute =&gt; Store</li></ul><h4 id="Fetch-Instrunction"><a href="#Fetch-Instrunction" class="headerlink" title="Fetch Instrunction"></a>Fetch Instrunction</h4><h6 id="AR-lt-PC-amp-IR-lt-M-AR-amp-PC"><a href="#AR-lt-PC-amp-IR-lt-M-AR-amp-PC" class="headerlink" title="AR &lt;- PC &amp; IR &lt;- M[AR] &amp; PC++"></a>AR &lt;- PC &amp; IR &lt;- M[AR] &amp; PC++</h6><h1 id="OS-Booting"><a href="#OS-Booting" class="headerlink" title="OS Booting"></a>OS Booting</h1><ul><li>CPU simply fetch, decode, execute, store each line of OS image</li><li>Activates scheduler(=swapper)(pid=0), first process init()(pid=1)</li><li>Waits for interrupts to occur</li><li>Hardware interrupts: signals CPU by bus</li><li>Software interrupts: signals by sys calls(traps)</li><li>Modern OSs are interrupt-driven</li><li><strong>Why interrupts necessary? : OS가 효율적으로 작동하기 위해</strong></li><li><strong>When interrupts necessary? : CPU가 요청한 operation을 I/O controller가 다 끝냈을 때</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Modern-Computer-Systems&quot;&gt;&lt;a href=&quot;#Modern-Computer-Systems&quot; class=&quot;headerlink&quot; title=&quot;Modern Computer Systems&quot;&gt;&lt;/a&gt;Modern Computer S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[알고리즘] 프로그래머스 크레인 인형뽑기 게임 파이썬 풀이</title>
    <link href="https://sj602.github.io/2020/04/03/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/"/>
    <id>https://sj602.github.io/2020/04/03/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/</id>
    <published>2020-04-03T07:26:47.000Z</published>
    <updated>2020-04-03T14:35:57.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h1><ul><li><a href="https://programmers.co.kr/learn/courses/30/lessons/64061" target="_blank" rel="noopener">https://programmers.co.kr/learn/courses/30/lessons/64061</a></li></ul><h1 id="풀이-방법"><a href="#풀이-방법" class="headerlink" title="풀이 방법"></a>풀이 방법</h1><p>스택을 이용한 전형적인 문제이다. moves 배열에서 인형뽑기를 할 각 열을 꺼내주고,</p><p>board의 해당 칸이 0보다 크면(=인형이 있으면) 그 인형을 뽑는다.</p><p>스택에 넣어주기 전, 스택의 top을 검사하여 뽑은 인형과 top이 같으면 인형 수를 2 증가시킨다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(board, moves)</span>:</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    moves = deque([move<span class="number">-1</span> <span class="keyword">for</span> move <span class="keyword">in</span> moves])</span><br><span class="line">    stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> moves:</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        j = moves.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                found=<span class="literal">True</span></span><br><span class="line">                curr = board[i][j]</span><br><span class="line">                board[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> found:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> curr == top:</span><br><span class="line">                answer+=<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(top)</span><br><span class="line">                stack.append(curr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(curr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h1 id="배운-점"><a href="#배운-점" class="headerlink" title="배운 점"></a>배운 점</h1><p>파이썬의 <strong>변수 스코프</strong>에 대해서 헷갈려서 자꾸 에러가 났었다.</p><p><strong>curr</strong> 변수가 루프를 돌면서 계속 살아있어서 만약 해당 칸에 인형이 없다고해도(=0) 전에 선택한 인형의 값이 남아있었다.</p><p>파이썬의 경우, <strong>블록 스코프</strong>를 가지고 있는 다른 언어(C, Javascript…)와 다르게 <strong>함수 스코프</strong>이고,</p><p>오직 <strong>글로벌 변수</strong>와 <strong>로컬 변수</strong>밖에 존재하지 않는다.</p><p>이 기회를 통해서 다시 한번 파이썬의 변수 스코프에 대해 알게 되었다.</p><h1 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h1><p>파이썬 변수 스코프에 관해서 - <a href="https://soooprmx.com/archives/5854" target="_blank" rel="noopener">https://soooprmx.com/archives/5854</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제-링크&quot;&gt;&lt;a href=&quot;#문제-링크&quot; class=&quot;headerlink&quot; title=&quot;문제 링크&quot;&gt;&lt;/a&gt;문제 링크&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/
      
    
    </summary>
    
    
      <category term="알고리즘" scheme="https://sj602.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
    
      <category term="알고리즘" scheme="https://sj602.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="프로그래머스" scheme="https://sj602.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="파이썬" scheme="https://sj602.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"/>
    
      <category term="python" scheme="https://sj602.github.io/tags/python/"/>
    
      <category term="2019 카카오 개발자 겨울 인턴십" scheme="https://sj602.github.io/tags/2019-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B2%A8%EC%9A%B8-%EC%9D%B8%ED%84%B4%EC%8B%AD/"/>
    
  </entry>
  
  <entry>
    <title>[운영체제] 2주차</title>
    <link href="https://sj602.github.io/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-2%EC%A3%BC%EC%B0%A8/"/>
    <id>https://sj602.github.io/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-2%EC%A3%BC%EC%B0%A8/</id>
    <published>2020-03-30T09:54:05.000Z</published>
    <updated>2020-04-03T10:29:25.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Special-Purpose-Registers"><a href="#Special-Purpose-Registers" class="headerlink" title="Special Purpose Registers"></a>Special Purpose Registers</h1><ul><li>AR(Address Register): 메모리 주소 저장, size 12</li><li>PC(Program Counter): 다음에 실행될 명령어의 주소 저장, size 12</li><li>IR(Instruction Register): 지금 실행될 명령어 저장, size 16</li><li>DR(Data Register): 데이터를 저장, size 16</li><li>TR(Temporary Register): 임시 데이터 저장, size 16</li><li>AC(Accumulator): 산술연산, AC &lt;- AC + DR, size 16</li></ul><h1 id="Data-units-in-CPU"><a href="#Data-units-in-CPU" class="headerlink" title="Data units in CPU"></a>Data units in CPU</h1><p><img src="/image/dataunitsincpu.png" alt=""></p><ul><li>이 그림을 그릴줄 알아야 함</li><li>7개의 레지스터가 버스를 통해서 서로 연결</li><li>데이터가 동시에 들어오면 안되기 때문에 MUX(multiplexer)를 통해 데이터를 보낼 레지스터 결정</li><li>ex: S2 = 1 S1 = 1 S0 = 1이라면, Memory Unit으로 데이터가 흘러감</li><li>ex: PC에 있는 값을 AR로 보내고 싶다면? S2, S1, S2를 각각 010으로 세팅하고 AR의 LD를 1로 세팅</li><li>LD(load): 이 단자의 값이 1이면 버스를 통해 해당 레지스터로 데이터가 들어옴</li><li>INR(increment): 이 단자의 값이 1이면 레지스터가 1 증가</li><li>CLR(clear): 이 단자의 값이 1이면 레지스터 값이 0이 됌</li><li>IR에는 레지스터 값이 변하면 안되므로 LD단자 밖에 없다</li><li>Memory Unit의 주소를 Address 단자를 통해 AR이 결정한다</li><li>E(overflow bit)</li></ul><h1 id="CPu-Instruction-Cycle"><a href="#CPu-Instruction-Cycle" class="headerlink" title="CPu Instruction Cycle"></a>CPu Instruction Cycle</h1><ol><li>Instruction Fetch</li></ol><ul><li>메모리에서 IR로 명령어를 가져옴</li></ul><ol start="2"><li>Decode</li></ol><ul><li>IR의 명령어 opcode를 알아냄</li></ul><ol start="3"><li>Decide effective address, if MRI instruction</li></ol><ul><li>메모리로부터 effective address를 읽어들임 (if I bit = 1)</li></ul><ol start="4"><li>Data Fetch, if necessary, if MRI instruction</li><li>Execute</li></ol><ul><li>decoded instruction을 실행</li></ul><ol start="6"><li>Store result data, if necessary</li></ol><ul><li>result data를 AC로부터 타겟 메모리 주소에 씀</li></ul><h1 id="예시로-보는-프로그램의-CPU단-실행-순서"><a href="#예시로-보는-프로그램의-CPU단-실행-순서" class="headerlink" title="예시로 보는 프로그램의 CPU단 실행 순서"></a>예시로 보는 프로그램의 CPU단 실행 순서</h1><ol><li>프로그램의 아이콘을 클릭</li><li>OS가 HDD(SSD)에서 해당 파일을 찾는다</li><li>OS가 메인메모리에서 빈 공간을 찾는다</li><li>OS가 프로그램의 첫 번째 명령어의 주소를 불러온다</li><li>CPU가 PC값을 AR로 보낸다 (AR &lt;- PC)</li><li>CPU가 M[AR]의 값을 IR로 보내고 PC값을 증가 시킴 (IR &lt;- M[AR], PC++)</li><li>CPU가 IR에 저장된 명령어를 decode한다 (AR &lt;- IR(0-11))</li><li>CPU가 메인메모리에서 DR로 데이터를 이동시킨다 (DR &lt;- M[AR])</li><li>CPU가 adder와 AC를 이용해 ADD op를 실행시킨다 (AC &lt;- AC+DR)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Special-Purpose-Registers&quot;&gt;&lt;a href=&quot;#Special-Purpose-Registers&quot; class=&quot;headerlink&quot; title=&quot;Special Purpose Registers&quot;&gt;&lt;/a&gt;Special Pur
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[컴퓨터구성] 2주차</title>
    <link href="https://sj602.github.io/2020/03/29/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1-2%EC%A3%BC%EC%B0%A8/"/>
    <id>https://sj602.github.io/2020/03/29/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1-2%EC%A3%BC%EC%B0%A8/</id>
    <published>2020-03-29T06:30:31.000Z</published>
    <updated>2020-03-29T14:29:53.075Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>(AND-OR === NAND-NAND, OR-AND === NOR-NOR)이므로 (AND-OR/OR-AND보다는 NAND-NAND/NOR-NOR를 쓰는게 더 저렴하다)</p></li><li><p>여러가지 Boolean Algebra의 정리를 이용해서 Logic minimization(# of gates, # of gate inputs)하는데 어떤 정리를 먼저 쓰냐에 따라 결과가 다르기 때문에 쉽지가 않다.</p></li><li><p>Don’t care condition: F값이 0/1이 정의되지 않는 경우로 0/1로 나눠서 2번 풀어서 비용을 비교해야함</p></li></ul><h1 id="Useful-Theorems"><a href="#Useful-Theorems" class="headerlink" title="Useful Theorems"></a>Useful Theorems</h1><ul><li><ol><li>x + xy = x, x + x’y = x+y</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>ab + b’c + ac = ab + b’c</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>if ab’ + a’b = ac’ + a’c, then b=c</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ab&#39; + a&#39;b &#x3D; ac&#39; + a&#39;c이 같다면 두 항을 xor취했을 때 결과가 0이 나와야 한다</span><br><span class="line">-&gt; ab&#39; + a&#39;b &#x3D; ac&#39; + a&#39;c</span><br><span class="line">-&gt; (a xor b) xor (a xor c) &#x3D; 0</span><br><span class="line">-&gt; a xor a xor b xor c &#x3D; 0</span><br><span class="line">-&gt; b xor c &#x3D; 0</span><br><span class="line">-&gt; hence, b &#x3D; c</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>if a = b, then a xor c = b xor c</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3번과 마찬가지로, xor 이용</span><br><span class="line">-&gt; (a xor c) xor (b xor c)</span><br><span class="line">-&gt; a xor b xor c xor c</span><br><span class="line">-&gt; a xor b &#x3D; 0</span><br><span class="line">-&gt; hence, a xor c &#x3D; b xor c</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>find the expression of f<br><img src="/image/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-2%EC%A3%BC%EC%B0%A8.png" alt=""></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>find the product-of-sum form of f = wxy + wx’y’ + w’xy’</li></ol></li></ul><h1 id="카르노맵"><a href="#카르노맵" class="headerlink" title="카르노맵"></a>카르노맵</h1><ul><li>이런 문제를 쉽게 풀고자 나온게 카르노맵</li><li>카르노맵의 출발은 AB’ + AB = A으로 Canonical Form을 나타내기에 충분하다라는 것</li><li>보통 입력수가 4개 이하일 때 카르노맵을 이용해서 문제를 푼다.</li><li>이웃한 1을 그룹지어 항을 만든다</li><li>테이블을 만들때, 변수가 하나씩 바뀌어야 한다</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(00, 01, 11, 10) &#x2F;&#x2F; O</span><br><span class="line">(00, 01, 10, 11) &#x2F;&#x2F; X</span><br></pre></td></tr></table></figure><ul><li>각 끝 행과 열은 처음 행과 열로 그룹지을 수 있다</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;(AND-OR === NAND-NAND, OR-AND === NOR-NOR)이므로 (AND-OR/OR-AND보다는 NAND-NAND/NOR-NOR를 쓰는게 더 저렴하다)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;여러가지 Boolean Alg
      
    
    </summary>
    
    
      <category term="컴퓨터구성" scheme="https://sj602.github.io/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1/"/>
    
    
      <category term="컴퓨터구성" scheme="https://sj602.github.io/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1/"/>
    
      <category term="Computer Architecture" scheme="https://sj602.github.io/tags/Computer-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>[운영체제] 1주차</title>
    <link href="https://sj602.github.io/2020/03/29/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-1%EC%A3%BC%EC%B0%A8/"/>
    <id>https://sj602.github.io/2020/03/29/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-1%EC%A3%BC%EC%B0%A8/</id>
    <published>2020-03-29T06:30:31.000Z</published>
    <updated>2020-04-03T08:59:39.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="운영체제의-목표"><a href="#운영체제의-목표" class="headerlink" title="운영체제의 목표"></a>운영체제의 목표</h1><ul><li>User convenience</li><li>Efficient Resource Management</li></ul><h1 id="운영체제-수업에서-12가지-룰"><a href="#운영체제-수업에서-12가지-룰" class="headerlink" title="운영체제 수업에서 12가지 룰"></a>운영체제 수업에서 12가지 룰</h1><h5 id="1-컴퓨터-시스템은-CPU-Memories-HDD-amp-IO-device-Bus로-구성되어있다"><a href="#1-컴퓨터-시스템은-CPU-Memories-HDD-amp-IO-device-Bus로-구성되어있다" class="headerlink" title="1) 컴퓨터 시스템은 CPU, Memories, HDD&amp;IO device + Bus로 구성되어있다"></a>1) 컴퓨터 시스템은 CPU, Memories, HDD&amp;IO device + Bus로 구성되어있다</h5><h5 id="2-CPU와-Main-Memory-만이-internal하고-다른-모든-것들은-external-디바이스"><a href="#2-CPU와-Main-Memory-만이-internal하고-다른-모든-것들은-external-디바이스" class="headerlink" title="2) CPU와 Main Memory 만이 internal하고 다른 모든 것들은 external 디바이스"></a>2) CPU와 Main Memory 만이 internal하고 다른 모든 것들은 external 디바이스</h5><h5 id="3-Storages는-2가지-종류로-구분"><a href="#3-Storages는-2가지-종류로-구분" class="headerlink" title="3) Storages는 2가지 종류로 구분"></a>3) Storages는 2가지 종류로 구분</h5><h6 id="Internal-register-cache-main-memory-gt-volatile"><a href="#Internal-register-cache-main-memory-gt-volatile" class="headerlink" title="- Internal: register, cache, main memory =&gt; volatile"></a>- Internal: register, cache, main memory =&gt; volatile</h6><h6 id="External-HDD-SSD-gt-permant"><a href="#External-HDD-SSD-gt-permant" class="headerlink" title="- External: HDD, SSD =&gt; permant"></a>- External: HDD, SSD =&gt; permant</h6><h5 id="4-모든-파일은-HDD에-저장된다고-가정"><a href="#4-모든-파일은-HDD에-저장된다고-가정" class="headerlink" title="4) 모든 파일은 HDD에 저장된다고 가정"></a>4) 모든 파일은 HDD에 저장된다고 가정</h5><h5 id="5-모든-프로그램은-CPU에-의해-HDD에서-Main-Memory로-적재된다"><a href="#5-모든-프로그램은-CPU에-의해-HDD에서-Main-Memory로-적재된다" class="headerlink" title="5) 모든 프로그램은 CPU에 의해 HDD에서 Main Memory로 적재된다"></a>5) 모든 프로그램은 CPU에 의해 HDD에서 Main Memory로 적재된다</h5><h5 id="6-Main-Memory는-일리노이-아키텍쳐-폰노이만-구조-Illinois-Architecture-로-가정"><a href="#6-Main-Memory는-일리노이-아키텍쳐-폰노이만-구조-Illinois-Architecture-로-가정" class="headerlink" title="6) Main Memory는 일리노이 아키텍쳐(=폰노이만 구조, Illinois Architecture)로 가정"></a>6) Main Memory는 일리노이 아키텍쳐(=폰노이만 구조, Illinois Architecture)로 가정</h5><h6 id="cf-하버드-아키텍쳐-Harvard-Architecture"><a href="#cf-하버드-아키텍쳐-Harvard-Architecture" class="headerlink" title="cf. 하버드 아키텍쳐(Harvard Architecture)"></a>cf. 하버드 아키텍쳐(Harvard Architecture)</h6><p><img src="/image/harvard-architecture.png" alt=""></p><h5 id="7-모든-internal-activities는-Main-Memory를-이용해-CPU에-의해-수행"><a href="#7-모든-internal-activities는-Main-Memory를-이용해-CPU에-의해-수행" class="headerlink" title="7) 모든 internal activities는 Main Memory를 이용해 CPU에 의해 수행"></a>7) 모든 internal activities는 Main Memory를 이용해 CPU에 의해 수행</h5><h6 id="if-there-are-activities-inside-computer-system-there-must-be-certain-programs-being-executed-by-CPU-only-using-MM"><a href="#if-there-are-activities-inside-computer-system-there-must-be-certain-programs-being-executed-by-CPU-only-using-MM" class="headerlink" title="if there are activities inside computer system, there must be certain programs being executed by CPU only using MM"></a>if there are activities inside computer system, there must be certain programs being executed by CPU only using MM</h6><h5 id="8-오직-2개의-프로그램만이-존재-User-program-amp-OS-program"><a href="#8-오직-2개의-프로그램만이-존재-User-program-amp-OS-program" class="headerlink" title="8) 오직 2개의 프로그램만이 존재: User program &amp; OS program"></a>8) 오직 2개의 프로그램만이 존재: User program &amp; OS program</h5><h5 id="9-User-program이-아닌-모든-프로그램은-OS-program"><a href="#9-User-program이-아닌-모든-프로그램은-OS-program" class="headerlink" title="9) User program이 아닌 모든 프로그램은 OS program"></a>9) User program이 아닌 모든 프로그램은 OS program</h5><h5 id="10-Osms-Process-Management-Resource-Management-Control-program을-수행"><a href="#10-Osms-Process-Management-Resource-Management-Control-program을-수행" class="headerlink" title="10) Osms Process Management, Resource Management, Control program을 수행"></a>10) Osms Process Management, Resource Management, Control program을 수행</h5><h5 id="11-multi-user-system을-가정"><a href="#11-multi-user-system을-가정" class="headerlink" title="11) multi-user system을 가정"></a>11) multi-user system을 가정</h5><h5 id="12-Computer-system-shared-by-users-must-keep-all-users-amp-programs-happy"><a href="#12-Computer-system-shared-by-users-must-keep-all-users-amp-programs-happy" class="headerlink" title="12) Computer system shared by users must keep all users &amp; programs happy"></a>12) Computer system shared by users must keep all users &amp; programs happy</h5><h5 id="happiness-from-user-convenience-fastness-and-fairness"><a href="#happiness-from-user-convenience-fastness-and-fairness" class="headerlink" title="happiness from user convenience, fastness and fairness"></a>happiness from user convenience, fastness and fairness</h5><h3 id="프로그램을-메모리에-적재에서-실행하는-이유"><a href="#프로그램을-메모리에-적재에서-실행하는-이유" class="headerlink" title="프로그램을 메모리에 적재에서 실행하는 이유?"></a>프로그램을 메모리에 적재에서 실행하는 이유?</h3><ul><li>CPU의 속도에 비해서 HDD/SSD의 속도가 너무 느려 더 빠른 Main Memory에 적재하여 실행</li></ul><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ul><li>LOAD vs STORE: Memory Hierarchy에서 데이터를 위로 보내면 LOAD, 아래로 보면 STORE</li><li>폰노이만 아키텍쳐 (일리노이 아키텍쳐): Data + Code가 모두 메모리 안에 저장</li><li>하버드 아키텍쳐: Date/Code 메모리가 분리되어 저장</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;운영체제의-목표&quot;&gt;&lt;a href=&quot;#운영체제의-목표&quot; class=&quot;headerlink&quot; title=&quot;운영체제의 목표&quot;&gt;&lt;/a&gt;운영체제의 목표&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;User convenience&lt;/li&gt;
&lt;li&gt;Efficient Reso
      
    
    </summary>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
      <category term="Operating System" scheme="https://sj602.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>[컴퓨터구성] 1주차</title>
    <link href="https://sj602.github.io/2020/03/16/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1-1%EC%A3%BC%EC%B0%A8/"/>
    <id>https://sj602.github.io/2020/03/16/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1-1%EC%A3%BC%EC%B0%A8/</id>
    <published>2020-03-16T06:30:31.000Z</published>
    <updated>2020-03-29T14:29:23.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h1><ul><li><p>refers to those attributes of the system that are visible to a programmer – those attributes that have a direct impact on the execution of a program (프로그래머에게 보이는 개념)</p></li><li><p>Instruction set: 3-, 2-, 1-, 0-address format, CISC and RISC, ……</p></li><li><p>Data representations: signed magnitude, 2’s complement, floating-point</p></li><li><p>Addressing: direct, indirect, relative, ……</p></li><li><p>I/O mechanisms: memory mapped, I/O mapped</p></li></ul><h1 id="Computer-Organization"><a href="#Computer-Organization" class="headerlink" title="Computer Organization"></a>Computer Organization</h1><p>Synonymous with architecture in many uses<br>프로그래머에게 보이지 않는 개념(더 로우레벨)<br>Device를 어떻게 만들 것인가?</p><h1 id="Why-Learn-Computer-Architecture"><a href="#Why-Learn-Computer-Architecture" class="headerlink" title="Why Learn Computer Architecture"></a>Why Learn Computer Architecture</h1><ul><li>CA lies between hardware and software</li><li>Hardware implies performance</li><li>Software affects usefulness (ease of use)</li><li>CA cannot be isolated from software issues (OS, complier, OOP, ……) and technology issues (memory technologies, underlying VLSI trends, ……)</li></ul><h1 id="폰노이만-구조"><a href="#폰노이만-구조" class="headerlink" title="폰노이만 구조"></a>폰노이만 구조</h1><ul><li>프로그램을 메모리에 저장해서 실행하는 개념</li><li>메모리에 저장하는 것이니 CPU 입장에서 불러오는 메모리의 내용만 바꾸면 매번 다른 일을 할 수 있다 =&gt; 소프트웨어 라는 개념이 탄생</li><li>단점으로는 CPU가 아무리 빨라도 메모리가 bottle neck이 된다는 것.</li><li>메모리 용량은 유지하면서 어떻게 하면 속도를 빠르게 할 수 있을까 라는 게 컴퓨터하는 사람들의 중요한 연구 주제</li></ul><h1 id="Logic-Gates"><a href="#Logic-Gates" class="headerlink" title="Logic Gates"></a>Logic Gates</h1><ul><li>AND/OR/NOT 만 있으면 모든 회로를 다 만들 수 있다(=Complete set)</li><li>사실은 여기 중에서도 AND/NOT 아니면 OR/NOT만 있어도 된다.</li><li>Buffer는 input/output이 똑같은데 왜 필요하나? =&gt; logical하게 의미는 없지만 신호의 특성을 바꿔준다</li><li>NAND가 중요한 게이트, 복잡해보이지만 만들기 쉬움. AND게이트를 만든 다음에 NOT을 붙인다(AND게이트보다 비용이 적게 듬), 수학적으로 문제를 풀 때는 Complete set(AND,OR,NOT)을 써야되지만 NAND게이트만 있으며 다 만들 수 있기 때문에 비용측면에서 많이 쓰인다</li><li>NOR도 NAND랑 마찬가지.</li><li>XOR: ODD function(1이 홀수개냐)으로 정의</li><li>XNOR: EVEN function(1이 짝수개냐)으로 정의</li></ul><h1 id="Canonical-Form-표준형식"><a href="#Canonical-Form-표준형식" class="headerlink" title="Canonical Form(표준형식)"></a>Canonical Form(표준형식)</h1><ul><li><p>Minterm: 1을 위주로…, AND-OR</p></li><li><p>Maxterm: 0을 위주로…, OR-AND</p></li><li><p>Minterm으로 만들어야 비용을 적게 들일 수 있다</p></li><li><p>예를 들어, XOR 게이트를 다음과 같이 나타낼 수 있다</p><table><thead><tr><th>a</th><th>b</th><th>f</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></li><li><p>Minterm</p></li><li><p>1을 기준으로 표현하여 각 항을 +한다</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; a&#39;b + ab&#39;</span><br></pre></td></tr></table></figure><ul><li>Maxterm</li><li>0을 기준으로 표현하여 각 항을 *한다</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; (a+b) * (a&#39;+b&#39;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Computer-Architecture&quot;&gt;&lt;a href=&quot;#Computer-Architecture&quot; class=&quot;headerlink&quot; title=&quot;Computer Architecture&quot;&gt;&lt;/a&gt;Computer Architecture&lt;/
      
    
    </summary>
    
    
      <category term="컴퓨터구성" scheme="https://sj602.github.io/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1/"/>
    
    
      <category term="컴퓨터구성" scheme="https://sj602.github.io/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1/"/>
    
      <category term="Computer Architecture" scheme="https://sj602.github.io/tags/Computer-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>[알고리즘] 병합정렬(머지소트/Merge Sort)</title>
    <link href="https://sj602.github.io/2020/03/16/mergesort/"/>
    <id>https://sj602.github.io/2020/03/16/mergesort/</id>
    <published>2020-03-15T23:27:55.749Z</published>
    <updated>2020-03-15T23:27:55.753Z</updated>
    
    <content type="html"><![CDATA[<p>병합정렬(Merge Sort)</p><p>나누는 부분인 mergesort()와<br>나눈 부분을 정렬을 하면서 합치는 merge()로 구분할 수 있다.<br>중간 중간 정렬된 원소들이 들어갈 임시 배열 sorted를 선언해줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">int sorted[10];</span><br><span class="line"></span><br><span class="line">mergesort(int arr[], int left, int right)&#123;</span><br><span class="line">    &#x2F;&#x2F; left가 right보다 작으면 계속 반씩 나눠준다. 크다면 아무런 동작도 하지 않고 빠져 나와 재귀함수의 merge부분으로 들어간다.</span><br><span class="line">    if(left &lt; right) &#123;</span><br><span class="line">        int mid &#x3D; (left+right)&#x2F;2;</span><br><span class="line">        </span><br><span class="line">        mergesort(arr, left, mid);</span><br><span class="line">        mergesort(arr, mid+1, right);</span><br><span class="line">        merge(arr, left, mid, right); &#x2F;&#x2F; 반씩 나눈 부분을 합친다.</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(int arr[], int left, int mid, int right)&#123;</span><br><span class="line">    int i &#x3D; left, j &#x3D; mid+1, k &#x3D; left;</span><br><span class="line">    &#x2F;&#x2F; 나눈 부분을 합친다</span><br><span class="line">    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; right) &#123;</span><br><span class="line">        if(arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            sorted[k] &#x3D; arr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sorted[k] &#x3D; arr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 왼쪽 부분이 먼저 끝날수도, 오른쪽 부분이 먼저 끝날수도 있기 때문에 남아있는 원소를 넣어준다.</span><br><span class="line">    if(i &gt; mid) &#123;</span><br><span class="line">        for(; j &lt;&#x3D; right; j++) &#123;</span><br><span class="line">            sorted[k] &#x3D; arr[j];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for(; i &lt;&#x3D; mid; i++) &#123;</span><br><span class="line">            sorted[k] &#x3D; arr[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 최종적으로 sorted배열에 있는 원소를 실제 배열인 arr로 옮겨준다</span><br><span class="line">    for(int m &#x3D; left; m &lt;&#x3D; right; m++) &#123;</span><br><span class="line">        arr[m] &#x3D; sorted[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>시간복잡도는 평균적인 경우나 최악의 경우에도 O(NlogN)을 보장한다.<br>왜냐면 원소들의 순서가 어떻든, 퀵소트처럼 이미 정렬이 됬든 안됬든, 무조건 낱개가 될때까지 반씩 나눈 다음에<br>낱개가 된 원소들끼리 합치면서 정렬을 하기 때문이다.<br>이미 공부를 했던 정렬인데 영상을 참고하면서 따라했다.<br>언제나 개념은 알고있지만 실제로 코드로 옮기는 부분에 있어서 문제가 많다.<br>Keep Going</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;병합정렬(Merge Sort)&lt;/p&gt;
&lt;p&gt;나누는 부분인 mergesort()와&lt;br&gt;나눈 부분을 정렬을 하면서 합치는 merge()로 구분할 수 있다.&lt;br&gt;중간 중간 정렬된 원소들이 들어갈 임시 배열 sorted를 선언해줘야 한다.&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="알고리즘" scheme="https://sj602.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
    
      <category term="알고리즘" scheme="https://sj602.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="병합정렬" scheme="https://sj602.github.io/tags/%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%AC/"/>
    
      <category term="머지소트" scheme="https://sj602.github.io/tags/%EB%A8%B8%EC%A7%80%EC%86%8C%ED%8A%B8/"/>
    
      <category term="mergesort" scheme="https://sj602.github.io/tags/mergesort/"/>
    
  </entry>
  
  <entry>
    <title>[책] 실용주의 사고와 학습</title>
    <link href="https://sj602.github.io/2019/01/04/pragmatic-thinking-and-learning/"/>
    <id>https://sj602.github.io/2019/01/04/pragmatic-thinking-and-learning/</id>
    <published>2019-01-04T11:48:03.000Z</published>
    <updated>2020-03-15T23:27:55.817Z</updated>
    
    <content type="html"><![CDATA[<p>리뷰라기 보다는 책을 읽고 내용이 머릿속에 잘 안 남는 것 같아 이렇게라도 따로 내용정리를 해둘려고 한다.<br>책의 내용을 그대로 쓴 것이 대부분이고 중간중간 나의 생각을 짧게 곁들일 것이다.<br>개발자라는 직업을 선택한 이상 또한 이 시대를 살아가는 현대인인 이상<br>매일 매일 새로운 것들을 배워야 하고 그 배움의 과정을 보다 효율적으로 할 수 없을까라는 궁금증을 풀어줄 수 있었다<br>배워야 한다는 사실에 스트레스 받지 않고 배움 자체를 즐기다보면 어느 순간 꼭대기에 올라가 있지 않을까</p><h1 id="실용주의-사고와-학습"><a href="#실용주의-사고와-학습" class="headerlink" title="실용주의 사고와 학습"></a>실용주의 사고와 학습</h1><ul><li>바람직한 어려움: 학습할 때 오히려 어려운 것들이 학생에게 더 이득이 되는 경우가 많다</li><li>학생들의 수업 만족도가 높은(잘 배웠다고 생각이 드는) 수업이 오히려 학생에게 해가 되는 경우가 있다</li><li>앞으로 의사소통 기술, 배우고 생각하는 기술이 중요</li><li>우리는 교사와 학생의 관계를 착각하는 경우가 많다. 학습은 교사가 가르치는게 아니라 학생이 배우는 것이다</li><li>삶에 있어서 고정불변인 것은 아무것도 없다. 오직 죽은 물고기만이 흐름을 따라간다</li><li>인간의 사고(인지)에는 내재된 편견이 있다<br>  _ 지금 내가 떠오르는 생각이 정답이 아닐 수 있다<br>  _ 인간의 생각은 단순한 사실 하나에도 영향을 받는다. 신입사원 면접을 보는 층으로 올라가기 위해 엘리베이터 안에서 마시는 커피가 아이스냐 핫이냐에 따라 그 면접관의 편향은 달라지는 것처럼..</li></ul><h2 id="드라이퍼스-모델"><a href="#드라이퍼스-모델" class="headerlink" title="드라이퍼스 모델"></a>드라이퍼스 모델</h2><ul><li>초보자는 규칙을 활용하고 전문가는 직관을 활용하라</li><li>초보자에서 전문가로 가는 과정에 동반되는 것<br>  _ 규칙에 의지 -&gt; 직관에 의존<br>  _ 관찰자 -&gt; 시스템의 일부(시스템적 사고)</li><li>사려 깊은 연습(말콤 글래드웰이 아웃라이어에서 말한 10년의 법칙, 칙센트미하이가 말한 ‘FLOW’ 상태에도 들어갈 수 있는 작업이니 이 얼마나 좋은 것인가..)<br>  _ 작업은 적당히 어려워야된다. 도전적이지만 할 수 있는 수준<br>  _ 피드백을 적극적으로 받을 수 있는 환경<br>  _ 반복하면서 잘못을 교정할 기회</li><li>근무 환경에 모범이 될 만한 사람에게 배우기 -&gt; 학교든 회사든 나만의 멘토를 정해 마음 속으로 정해서 따라해야겠다!</li></ul><h2 id="두-개의-CPU-모드"><a href="#두-개의-CPU-모드" class="headerlink" title="두 개의 CPU 모드"></a>두 개의 CPU 모드</h2><ul><li>우리의 뇌는 두 개의 모드로 구성(L모드, R모드)</li><li>L모드: 선형적, 논리적, 언어처리</li><li>R모드: 직관, 문제해결, 창조성</li><li>두 가지 모두 필요</li><li>R모드는 예측할 수 없기 때문에 늘 R모드가 주는 해답이나 통찰력을 대비해야 한다<br>  _ 어떤 아이디어가 떠오르면 바로 잡을 수 있도록 24시간 준비되있어야 한다<br>  _ 좋은 아이디어는 누구나 갖고 있으나 아주 일부만이 그 아이디어를 기록하는 수고를 한다<br>  _ 그 중에 아주 일부만이 아이디어를 실천한다<br>  _ 그 중에 아주 일부만이 아이디어를 성공시킨다<br>  _ 최소한 기록이라도 해둬야지 윗 단계의 가능성이 열리므로 아이폰의 메모장을 잘 활용해서 늘 기록하자!</li><li><blockquote><p>컴퓨터는 쓸모없다. 컴퓨터는 오로지 답을 줄 뿐이다 - 파블로 피카소</p></blockquote></li><li>질문이 더 중요하다는 얘기(R모드의 중요성)</li><li>상품화란 심미성을 겨루는 것이다. 좋은 디자인을 위해 노력하자 (ex: 마이크로소프트가 아이폰을 만든다면? 포장박스부터 덕지덕지 문구..)</li><li>연구 결과: 매력적인 사용자가 인터페이스가 못 생긴 인터페이스보다 더 사용하기 쉽다</li><li>뇌의 가소성: 가능성을 믿는한 뇌의 상한은 존재하지 않는다<br>  _ Impossible is nothing<br>  _ 생각하는 대로 된다<br>  _ 용불용설<br>  _ 외국어를 배우고 싶다? 늘 그언어로 말하고 생각<ul><li>코딩을 잘하고 싶다? 코딩을 더해라..</li></ul></li><li>지각력 있는 뇌의 R모드에 접근하려면 언어적이고 분석적인 L모드를 꺼버릴 만한 일을 주어야 한다 (음악 듣기, 그림 그리기, 명상, 조깅 등등)<br>  _ 요즘 공부를 하면서 재즈를 들으면서 하고 있는데 이게 생각 외로 큰 도움이 되는 것 같다<br>  _ 뒤늦게 공부를 시작한 나로선 공부에 대한 압박감이 있는데 공부라는 것이 L모드와 R모드가 조합이 되어야 한다면 무조건적으로 시간을 많이 투자해 앉아서 책읽기같은 전통적인 공부 방법에 치중해서는 안된다<br>  _ 때로는 공부/코딩 이외의 활동을 하면서 일부로 공부와 전혀 상관없는 활동을 해야된다는 말이고 넓게 보면 모든 일은 한번씩 해봄으로써 새로운 경험이 될 것이다<br>  _ 나에겐 웨이트를 꾸준히 하는 것이 그 예<br>  _ 어려운 문제를 풀려면 키보드에서 떨어져라</li><li>변화는 좋은 것이다<br>  _ 깊이 물든 습관은 뇌에 좋지 않음<br>  _ 뇌는 적응해야하는 것이 없다면 축 늘어지게 됨<br>  _ 일상적으로 하는 작은 행동에도 변화를 줘보자(양치를 할 때 왼손으로 하기 등)</li></ul><h2 id="당신의-마음을-디버그하라"><a href="#당신의-마음을-디버그하라" class="headerlink" title="당신의 마음을 디버그하라"></a>당신의 마음을 디버그하라</h2><ul><li>상관 관계 VS 인과 관계<br>  _ 단순한 상관 관계를 원인과 결과로 오해하기 쉽다<br>  _ 두 변수가 연관되어 있다는 것이 꼭 어느 한 쪽이 다른 쪽의 원인이라는 것은 아니다</li><li>기억보다 글로 쓴 것을 신뢰하라. 기억은 모두 읽기와 쓰기가 함께 일어난다</li><li>여러분이 무엇인가를 엄청나게 확실하고 있을 때 자신에게 왜냐고 물어보자<br>  _ 어떻게 알았는가?<br>  _ 누가 말한 것인가?<br>  _ 구체적으로 어떠한가?<br>  _ 내가 하고 있는 일이 당신에게는 어떤 영향을 주는가?<br>  _ 무엇이랑 비교하면? 혹은 누구랑 비교하면?<br>  _ 항상 일어나는가? 예외는 없는가?<br>  _ 당신이 했다면 어땠겠는가?<br>  _ 무엇때문에 못하는가?<br>  _ 언론들도 왜곡 보도를 하고 가짜 뉴스가 판 치는 세상에서 인터넷에서 단순히 어떤 사실을 봤다고 믿지 말자. 진정한 정보를 가려내는 능력을 길러야 한다</li></ul><h2 id="의도적으로-배우라"><a href="#의도적으로-배우라" class="headerlink" title="의도적으로 배우라"></a>의도적으로 배우라</h2><ul><li>현재의 기술과 문화에서 배우는 능력은 성공에 있어 가장 중요한 요소</li><li>교육(education)이란 단어는 라틴어 educare에서 온 단어인데 ‘끄집어낸다’라는 의미.</li><li>학습은 누군가가 여러분에게 해주는 것이 아니다. 여러분이 하는 것이다.</li><li>지식을 경험없이 그 자체로만 습득하는 것은 효과적이지 않다 -&gt; 목적없이 책읽기?</li><li>목표와 피드백 없이 무작위로 접근하게 되면 무작위적인 결과를 낳는다</li><li>SMART한 목표 설정<br>  _ Specific(구체적인)<br>  _ Measurable(측정 가능한)<br>  _ Achievable(달성 가능한)<br>  _ Relavant(의미 있는)<br>  _ Time-Boxed(시간 제한이 있는)</li><li><blockquote><p>계획하기는 계획 그 자체보다 중요하다 - 아이젠하워</p></blockquote></li><li>독서할 때의 의식적인 SQ3R 학습법<br>  _ Survey(훑어보기): 목차를 보면서 훑어보며 전체적인 개요 파악<br>  _ Question(질문): 생각나는 질문들을 적어놓기<br>  _ Read(읽기)<br>  _ Recite(낭송): 요약하고 메모하고 스스로 표현해보기<br>  _ Review(복습): 다시 읽고 메모를 확장하고 동료와 토론</li><li>마인드맵</li><li>타이핑보다는 손글씨</li><li>가르치며 배우기 -&gt; <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" target="_blank" rel="noopener">러버덕디버깅</a></li></ul><h2 id="경험-축적"><a href="#경험-축적" class="headerlink" title="경험 축적"></a>경험 축적</h2><ul><li>배우기 위해 놀기 -&gt; 그 언어를 공부하고 그 라이브러리를 공부하기 전에 일단 그 언어로 뭐라도 만들어보자. Learning by Coding</li><li>압박은 인지를 죽인다<br>  _ 촉박한 마감이 닥쳐야 가장 효과적인 것은 L모드에 일정 부분 유효하지만 R모드에서는 그렇지 않다<ul><li>시간 압박은 후유증까지 남긴다. 벼락치기는 이틀 정도는 축 처지게 됨</li></ul></li><li>뇌는 입력의 원천이 뭔지에 대해 속기 쉽기 때문에 성공을 상상하는 것은 그것을 달성하는데 확실히 효과적이다 -&gt; 이미 한 것처럼 연기하기 / 이미지 트레이닝</li><li>우리는 모방자다 -&gt; 나보다 뛰어난 사람들 속에 있기</li></ul><h2 id="초점-관리하기"><a href="#초점-관리하기" class="headerlink" title="초점 관리하기"></a>초점 관리하기</h2><ul><li>정보가 넘쳐나는 시대에서 정보 과잉은 지식과 주의의 결핍을 만들었다<br>  _ 어쩌면 미래는 이러한 노이즈에 집중하지 않고 자신의 것을 묵묵히 꾸준히 하는 사람에 있지 않을까? </li><li>명상의 이득: 명상을 할 때나 의식적으로 주의를 기울일 때뿐만 아니라 하루 종일 효과가 있다 -&gt; 명상앱은 오늘부터 깔아서 자기 전에 10분이라도 해봐야겠다라는 생각을 했는데 앉아서 해야된다네..</li><li>멀티태스킹을 하지 말자. 우리의 뇌는 컴퓨터와 달라서 Context Switching시 20분의 시간이 든다.<br>  _ 대마초를 피우는 것보다 계속 메일을 확인 하는 것이 우리의 아이큐를 더 떨어뜨린다고 한다<br>  _ 윈도우나 맥에서 알트탭, 커맨드탭으로 화면전환하는 것조차 단기기억과 에너지를 필요로 한다<br>  _ 더블 모니터를 쓰기만 해도 생산성이 30퍼센트 올라감</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;리뷰라기 보다는 책을 읽고 내용이 머릿속에 잘 안 남는 것 같아 이렇게라도 따로 내용정리를 해둘려고 한다.&lt;br&gt;책의 내용을 그대로 쓴 것이 대부분이고 중간중간 나의 생각을 짧게 곁들일 것이다.&lt;br&gt;개발자라는 직업을 선택한 이상 또한 이 시대를
      
    
    </summary>
    
    
      <category term="리뷰" scheme="https://sj602.github.io/categories/%EB%A6%AC%EB%B7%B0/"/>
    
    
      <category term="책" scheme="https://sj602.github.io/tags/%EC%B1%85/"/>
    
      <category term="실용주의 사고와 학습" scheme="https://sj602.github.io/tags/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EC%82%AC%EA%B3%A0%EC%99%80-%ED%95%99%EC%8A%B5/"/>
    
      <category term="리뷰" scheme="https://sj602.github.io/tags/%EB%A6%AC%EB%B7%B0/"/>
    
  </entry>
  
  <entry>
    <title>[운영체제] 4장 5장 Semaphore, Monitor 요약</title>
    <link href="https://sj602.github.io/2019/01/01/operating-system-chapter-4and5/"/>
    <id>https://sj602.github.io/2019/01/01/operating-system-chapter-4and5/</id>
    <published>2019-01-01T05:08:09.000Z</published>
    <updated>2020-03-15T23:27:55.817Z</updated>
    
    <content type="html"><![CDATA[<ol start="0"><li>임계영역(Critical Section)</li></ol><ul><li><p>다수의 프로세스가 접근 가능한 영역이면서 한 순간에 하나의 프로세스만 사용할 수 있는 영역</p></li><li><p>어떤 프로세스가 임계영역에 들어가면 다른 프로세스는 임계영역으로의 진입이 금지되어야 한다</p></li><li><p>프로세스/스레드 동기화를 함으로써 임계구역 문제를 해결하고 프로세스 실행 순서를 제어할 수 있다</p></li><li><p>임계영역 문제 해결책</p></li><li><p>상호배제(Mutual Exclusion): 한 프로세스가 임계영역에서 작업시 다른 프로세스는 접근 불가능</p></li><li><p>진행(Progress): 임계영역에서 작업하는 프로세스가 없을 때 여러 프로세스가 임계영역에 진입하고자 한다면 알고리즘에 따라 프로세스 선정, 프로세스 선택을 무한정 미룰 수 없다</p></li><li><p>제한된 대기(Bounded Waiting): 한 프로세스가 임계영역 진입을 요청한 후 수락되기 전까지 다른 프로세스가 진입할 수 있는 횟수를 제한</p></li><li><p>동기화 도구: 세마포어, 모니터</p></li></ul><ol><li>세마포어(Semaphore)</li></ol><ul><li>다익스트라가 제안</li><li>구조: 정수형 변수 + 두 개의 동작(P, V)</li><li>세마포어란 음이 아닌 정수값을 가지는 플래그 변수</li><li>임계영역에 들어가기전에 P: acquire() 하고 </li><li>임계영역으로부터 나올 때 V: release() 한다</li><li>P와 V를 다음과 같이 정의한다<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- P(S): while S &lt;&#x3D; 0 do no-op; &#x2F;&#x2F; 세마포어 변수 S가 0이면 임계구역 진입 불가</span><br><span class="line">    S &#x3D; S - 1; &#x2F;&#x2F; 세마포어 변수 S가 1이면 진입하여 0으로 만든 후 다른 프로세스 진입 못 하게 블락</span><br><span class="line">- V(S): S &#x3D; S + 1; &#x2F;&#x2F; 작업을 완료하고 나올 때 1을 더해줘 다른 프로세스가 진입 가능하게 만듬</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>모니터(Monitor)</li></ol><ul><li>세마포어보다 고수준의 개념</li><li>구조: 공유자원 + 공유자원 접근 함수</li><li>2개의 queues: 배타동기 + 조건동기</li></ul><ol start="3"><li>교착상태(Deadlock)</li></ol><ul><li>교착상태의 필요조건: 상호배타(Mutual Exclusion), 보유 및 대기(Hold and Wait), 비선점(No Preemption), 환형대기(Circular Wait)</li><li>교착상태의 처리: 방지, 회피, 검출 및 복구, 무시</li><li>실제 상황에서 교착상태는 잘 일어나지 않는다</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;임계영역(Critical Section)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;다수의 프로세스가 접근 가능한 영역이면서 한 순간에 하나의 프로세스만 사용할 수 있는 영역&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;어떤 프로세스
      
    
    </summary>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
      <category term="OS" scheme="https://sj602.github.io/tags/OS/"/>
    
      <category term="임계영역" scheme="https://sj602.github.io/tags/%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD/"/>
    
      <category term="Critical Section" scheme="https://sj602.github.io/tags/Critical-Section/"/>
    
      <category term="세마포어" scheme="https://sj602.github.io/tags/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"/>
    
      <category term="Semaphore" scheme="https://sj602.github.io/tags/Semaphore/"/>
    
      <category term="모니터" scheme="https://sj602.github.io/tags/%EB%AA%A8%EB%8B%88%ED%84%B0/"/>
    
      <category term="Monitor" scheme="https://sj602.github.io/tags/Monitor/"/>
    
      <category term="Mutual Exclusion" scheme="https://sj602.github.io/tags/Mutual-Exclusion/"/>
    
      <category term="상호배제" scheme="https://sj602.github.io/tags/%EC%83%81%ED%98%B8%EB%B0%B0%EC%A0%9C/"/>
    
      <category term="데드락" scheme="https://sj602.github.io/tags/%EB%8D%B0%EB%93%9C%EB%9D%BD/"/>
    
      <category term="Deadlock" scheme="https://sj602.github.io/tags/Deadlock/"/>
    
  </entry>
  
  <entry>
    <title>[운영체제] 3장 프로세스, 스레드 요약</title>
    <link href="https://sj602.github.io/2018/12/31/operating-system-chapter-3/"/>
    <id>https://sj602.github.io/2018/12/31/operating-system-chapter-3/</id>
    <published>2018-12-31T04:31:56.000Z</published>
    <updated>2020-03-15T23:27:55.754Z</updated>
    
    <content type="html"><![CDATA[<p>3장. 프로세스, 스레드</p><ol><li>프로세스</li></ol><ul><li>프로세스: 메모리에 적재되서 현재 실행 중인 프로그램</li><li>각 프로세스마다 코드, 데이터, BSS, 힙, 스택 등의 메모리 구조를 가짐</li><li>프로세스는 운영체제 내에서 프로세스 제어 블록(PCB: Process Control Block)으로 표현됨</li><li>PCB에는 프로세스 식별자, 프로세스 상태, 프로그램 카운터, 레지스터 등이 저장된다</li><li>문맥교환(Context Switching): 프로세스끼리 제어 상태 변화가 일어났을 때 발생 -&gt; 오버헤드(Overhead) 발생</li><li>OS의 스케쥴링에 의해 프로세스 실행 순서 결정</li><li>각각의 프로세스는 독립적이므로 한 프로세스가 비정상적으로 종료되도 다른 프로세스에 영향이 없다</li></ul><ol start="2"><li>스레드</li></ol><ul><li>스레드: 하나의 프로세스 내에서 실행되는 여러 흐름의 단위</li><li>각 스레드는 스택만 할당받고 코드, 데이터, 힙 등은 프로세스 내에서 공유한다</li><li>OS의 스케쥴러는 스레드를 최소 단위로 작업</li><li>각각의 스레드는 프로세스와 달리 비정상적으로 종료되면 다른 스레드들도 종료된</li></ul><ol start="3"><li>기타</li></ol><ul><li>일반적으로 새로운 프로세스가 생성되면 프로세스를 위한 스레드도 함께 생성된다</li><li>프로세스의 생성/종료보다 스레드의 생성/종료의 오버헤드가 훨씬 적다</li><li>트랩(Trap): 부적절한 파일접근이나 오류, 예외 상황때문에 발생 -&gt; 소프트웨어적인 흐름의 변화 (인터럽트: 하드웨어적인 흐름의 변)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3장. 프로세스, 스레드&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;프로세스&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;프로세스: 메모리에 적재되서 현재 실행 중인 프로그램&lt;/li&gt;
&lt;li&gt;각 프로세스마다 코드, 데이터, BSS, 힙, 스택 등의 메모리 구조를 가짐&lt;/li
      
    
    </summary>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
      <category term="OS" scheme="https://sj602.github.io/tags/OS/"/>
    
      <category term="프로세스" scheme="https://sj602.github.io/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/"/>
    
      <category term="스레드" scheme="https://sj602.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>[운영체제] 1장 2장 요약</title>
    <link href="https://sj602.github.io/2018/12/29/operating-system-chapter-1and2/"/>
    <id>https://sj602.github.io/2018/12/29/operating-system-chapter-1and2/</id>
    <published>2018-12-29T11:29:20.000Z</published>
    <updated>2020-03-15T23:27:55.753Z</updated>
    
    <content type="html"><![CDATA[<p>학교에 가기전 전공과목에 대해서 공부하고 있다. 중요한 과목들은 다 파악이 됬고<br>훑어보는 목적으로 각 과목에 대해서 알아보고자 한다. 강의는 경성대 양희재 교수님의 강의로 주로 공부를 하며<br>도서관에서 빌린 &lt;운영체제 : 그림으로 배우는 원리와 구조&gt;라는 책을 읽고 모자란 설명을 채울 생각이다.</p><p>1장과 2장은 서론같은 느낌이라서 한 포스트에 요약하겠다.</p><p>1장. 컴퓨터 시스템 소개</p><ol><li>컴퓨터 시스템 구성요소</li></ol><p>1) 프로세서</p><ul><li>중앙처리장치(CPU) : 레지스터, 산술논리연산장치(ALU), 제어장치</li></ul><p>2) 버스</p><p>3) 레지스터</p><ul><li>프로그램 카운터(PC: Program Counter): 프로그램 수행을 제어하는 명령어 실행 순서 보관(다음에 실행할 명령어 주소 저장)</li><li>명령어 레지스터(IR: Instrument Register): 현재 수행하는 명령어를 저장, 명령어의 연산자 부분만 저장한다.</li><li>프로그램 상태 레지스터(PSR: Program Status Register): 플래그 같은 상태 정보 저장</li><li>메모리 주소 레지스터(MAR: Memory Address Register): 접근하려는 메모리의 주소 저장</li><li>메모리 버퍼 레지스터(MBR: Memory Buffer Register): 메모리에서 정보를 읽거나 저장할 때 사용</li></ul><p>4) 메모리</p><ul><li>메모리의 지역성: 실행 중인 프로세서가 실행기간 동안 메모리 정보를 균일하게 접근하지 않고 일부만 집중적을 참조</li><li>메모리 속도: 메모리 사이클 시간 &amp; 메모리 접근 시간</li><li>가상 메모리(Virtual Memory): 보조기억장치에 저장했다가 주기억장치에 필요할 때 실행</li><li>메모리의 논리적 주소 -&gt; 물리적 주소 : Memory Mapping (메모리 관리 장치 MMU: Memory Management Unit이 해줌)</li><li>캐시(Cache): 처리 속도가 빠른 프로세서와 상대적으로 느린 주기억장치 사이에서 데이터를 저장하여 속도 차이를 줄여줌. 주기억장치<br>에서 일정 블록의 데이터를 가져와 워드(Word) 단위로 프로세서에 전달</li><li>프로세서는 주기억장치 접근이 필요하면 먼저 캐시를 조사</li><li>캐시 태그와 원하는 메모리 주소 태그가 일치하면 캐시 적중(Cache Hit)라 한다 &lt;-&gt; 캐시 실패(Cache Miss)</li></ul><p>5) 주변장치</p><ul><li>키보드, 마우스 등</li></ul><ol start="2"><li>컴퓨터 시스템의 동작</li></ol><p>1) 명령어 구성</p><ul><li>실행할 연산을 나타내는 연산 코드(Operation Code) &amp; 처리할 데이터가 저장된 주소를 나타내는 오퍼랜드(Operand)로 이루어짐</li><li>직접 주소와 간접 주소</li></ul><p>2) 인터럽트</p><ul><li>인터럽트를 받은 프로그램은 실행을 멈추고 다른 프로그램을 실행한다</li><li>입출력장치가 새로운 입출력 연산을 수행하려고 하면 프로세서는 폴링(Polling)을 통해 각 장치의 상태 비트 검사 (폴링 방식)</li><li>인터럽트가 발생했을 때 프로세서에게 알려줌. 버스 중 인터럽트 요청 회선(IRQ: Interrupt Request Line)이 이런 용도로 쓰임(인터럽트 방식)</li></ul><p>2장. 운영체제 소개</p><ol><li>운영체제의 기능</li></ol><ul><li>버퍼링과 스풀링 모두 입출력장치의 느린 속도를 보완하기 위해 이용하고 프로세서와 입출력장치를 항상 분주하게, 유휴 시간이 없게 만듬</li><li>버퍼링(Buffering): 주기억장치(보통 캐시메모리)를 버퍼로 사용</li><li>스풀링(Spooling): 보조기억장치(하드디스크)를 버퍼로 사용</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;학교에 가기전 전공과목에 대해서 공부하고 있다. 중요한 과목들은 다 파악이 됬고&lt;br&gt;훑어보는 목적으로 각 과목에 대해서 알아보고자 한다. 강의는 경성대 양희재 교수님의 강의로 주로 공부를 하며&lt;br&gt;도서관에서 빌린 &amp;lt;운영체제 : 그림으로 
      
    
    </summary>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
    
      <category term="운영체제" scheme="https://sj602.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
      <category term="OS" scheme="https://sj602.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>[보안] CSRF(Cross Site Request Forgery)란 무엇인가?</title>
    <link href="https://sj602.github.io/2018/07/14/what-is-CSRF/"/>
    <id>https://sj602.github.io/2018/07/14/what-is-CSRF/</id>
    <published>2018-07-14T08:34:18.000Z</published>
    <updated>2020-03-15T23:27:55.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF란-무엇인가"><a href="#CSRF란-무엇인가" class="headerlink" title="CSRF란 무엇인가?"></a>CSRF란 무엇인가?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSRF(Cross Stie Request Forgery) : 사이트간 요청 위조</span><br><span class="line">웹 애플리케이션 취약점 중 하나로 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹페이지를 보안에 취약하게 한다거나 수정, 삭제 등의 작업을 하게 만드는 공격방법을 의미한다 - 나무위키</span><br></pre></td></tr></table></figure><p>정의만 보면 앞서 알아봤던 <code>XSS</code>와 <code>SQL injection</code>과 비슷하다.<br><code>XSS</code>가 사용자가 특정 사이트를 신뢰한다는 점을 공격하는거라면, <code>CSRF</code>는 특정 사이트가 사용자의 브라우저를 신뢰한다는 점을 공격하는 것이 다르다.</p><p>간단하게 정리하자면, 악성코드가<br>XSS: 클라이언트에서 발생 / CSRF: 서버에서 발생<br>이라고 할 수 있다.</p><p>2008년도에 있었던 옥션 해킹 사고도 CSRF로 공격을 했다고 한다. (해커가 옥션 운영자에게 CSRF 코드가 포함된 이메일을 보내서 관리자 권한을 얻어냈다)</p><h1 id="공격-과정"><a href="#공격-과정" class="headerlink" title="공격 과정"></a>공격 과정</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;auction.com&#x2F;changeUserAcoount?id&#x3D;admin&amp;password&#x3D;admin&quot; width&#x3D;&quot;0&quot; height&#x3D;&quot;0&quot;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>위 옥션 사건을 예로 들어보자.</p><ol start="0"><li>옥션 관리자 중 한명이 관리 권한을 가지고 회사내에서 작업을 하던 중 메일을 조회한다. (로그인이 이미 되어있다고 가정하면 관리자로서의 유효한 쿠키를 갖고있음)</li><li>해커는 위와 같이 태그가 들어간 코드가 담긴 이메일을 보낸다. 관리자는 이미지 크기가 0이므로 전혀 알지 못한다.</li><li>피해자가 이메일을 열어볼 때, 이미지 파일을 받아오기 위해 URL이 열린다.</li><li>해커가 원하는 대로 관리자의 계정이 id와 pw 모두 admin인 계정으로 변경된다.</li></ol><h1 id="방어-방법"><a href="#방어-방법" class="headerlink" title="방어 방법"></a>방어 방법</h1><h4 id="1-Referrer-검증"><a href="#1-Referrer-검증" class="headerlink" title="1. Referrer 검증"></a>1. Referrer 검증</h4><p>request header에 있는 요청을 한 페이지의 정보가 담긴 referrer 속성을 검증하여 차단.<br>일반적으로 이 방법만으로도 대부분 방어가 가능할 수 있다.<br>옥션이 아닌 개인 이메일에서 요청이 들어오는 것처럼,<br>같은 도메인 상에서 요청이 들어오지 않는다면 차단하도록 하는 것이다.</p><h4 id="2-CSRF-Token-사용"><a href="#2-CSRF-Token-사용" class="headerlink" title="2. CSRF Token 사용"></a>2. CSRF Token 사용</h4><p>랜덤한 수를 사용자의 세션에 저장하여 사용자의 모든 요청(Request)에 대하여 서버단에서 검증하는 방법.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 로그인시, 또는 작업화면 요청시 CSRF 토큰을 생성하여 세션에 저장한다. </span><br><span class="line">session.setAttribute(&quot;CSRF_TOKEN&quot;,UUID.randomUUID().toString()); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 요청 페이지에 CSRF 토큰을 셋팅하여 전송한다 </span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_csrf&quot; value&#x3D;&quot;$&#123;CSRF_TOKEN&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="3-CAPTCHA-사용"><a href="#3-CAPTCHA-사용" class="headerlink" title="3. CAPTCHA 사용"></a>3. CAPTCHA 사용</h4><p>요즘은 거의 모든 웹사이트에서 캡차를 이용하는 것 같은데 캡차이미지상의 숫자/문자가 아니라면 해당 요청을 거부하는 것이다.</p><p>이 외에도 form 태그를 입력할 시 GET방식을 지양하고 POST방식을 쓰도록 하는 것은 기본이라고 할 수 있다.</p><hr><p>출처 : <a href="https://namu.wiki/w/CSRF" target="_blank" rel="noopener">나무위키</a>, <a href="https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%9A%94%EC%B2%AD_%EC%9C%84%EC%A1%B0" target="_blank" rel="noopener">위키피디아</a>,<br><a href="http://blog.ilkyu.kr/entry/CSRF-Crosssite-Request-Forgery-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%84-%EC%9A%94%EC%B2%AD-%EC%9C%84%EC%A1%B0" target="_blank" rel="noopener">http://blog.ilkyu.kr/entry/CSRF-Crosssite-Request-Forgery-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B0%84-%EC%9A%94%EC%B2%AD-%EC%9C%84%EC%A1%B0</a>,<br><a href="http://itstory.tk/entry/CSRF-공격이란-그리고-CSRF-방어-방법" target="_blank" rel="noopener">http://itstory.tk/entry/CSRF-공격이란-그리고-CSRF-방어-방법</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSRF란-무엇인가&quot;&gt;&lt;a href=&quot;#CSRF란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;CSRF란 무엇인가?&quot;&gt;&lt;/a&gt;CSRF란 무엇인가?&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="보안" scheme="https://sj602.github.io/categories/%EB%B3%B4%EC%95%88/"/>
    
    
      <category term="보안" scheme="https://sj602.github.io/tags/%EB%B3%B4%EC%95%88/"/>
    
      <category term="CSRF" scheme="https://sj602.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>[보안] SQL injection 이란?</title>
    <link href="https://sj602.github.io/2018/07/13/what-is-SQL-injection/"/>
    <id>https://sj602.github.io/2018/07/13/what-is-SQL-injection/</id>
    <published>2018-07-13T10:26:17.000Z</published>
    <updated>2020-03-15T23:27:55.754Z</updated>
    
    <content type="html"><![CDATA[<p>XSS와 더불어 가장 흔한 보안 공격 기술인 <strong>SQL injection</strong>에 대해서 알아보았다.</p><h1 id="SQL-injection-이란"><a href="#SQL-injection-이란" class="headerlink" title="SQL injection 이란?"></a>SQL injection 이란?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL 인젝션은 코드 인젝션의 한 기법으로 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격할 수 있는 공격방식을 말한다. - 나무위키</span><br></pre></td></tr></table></figure><p>데이터베이스 조작언어인 SQL 입력값에 정상적인 값이 아닌 SQL문을 삽입해 데이터베이스에 해를 가하는 공격이라고 할 수 있다.</p><p>예를 들어, 로그인을 하는 코드가 있다고 하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user FROM user_table WHERE id&#x3D;&#39;입력한 아이디&#39; AND password&#x3D;&#39;입력한 비밀번호&#39;;</span><br></pre></td></tr></table></figure><p>위와 같이 SQL문을 짜서 데이터베이스에 존재하는 user_table 테이블에서 입력한 id와 입력한 password와 동일한 값을 찾아 반환해주는 코드이다.</p><p>일반적인 유저라면</p><blockquote><p>id = 홍길동<br>password = 1234</p></blockquote><p>이런식으로 입력을 하겠지만</p><p>SQl injection을 할 유저는</p><blockquote><p>id = 홍길동<br>password = 1234’; DROP table user_table–</p></blockquote><p>이런식으로 입력을 하게 된다.</p><p>그렇게 되면 전체 SQL 구문은 이렇게 되어버린다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT user FROM user_table </span><br><span class="line">WHERE id&#x3D;&#39;홍길동&#39; AND password&#x3D;&#39;1234&#39;; DROP TABLE user_table--&#39;;</span><br></pre></td></tr></table></figure><p>SQL에서 ;(세미콜론)은 한 구문의 끝을 나타내므로 위 구문은</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user FROM user_table WHERE id&#x3D;&#39;홍길동&#39; AND password&#x3D;&#39;1234&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE user_table--&#39;</span><br></pre></td></tr></table></figure><p>이렇게 2개의 구문으로 나눠져 실행되게 된다.</p><p>–(하이픈 2개) 다음으로 오는 문장은 주석 처리가 되므로,<br>결국 DROP 명령어에 의해 해당 table은 DB에서 지워지게 된다.</p><p>이 외에도 로그인을 무조건 성공하게 하는<br><strong>‘ OR ‘1’ = ‘1</strong> (1은 1과 같으니 WHERE절은 무조건 참이 되어 아이디 또는 비밀번호가 무엇이든 로그인 성공)<br>등 수많은 케이스가 있다.</p><hr><h1 id="방어-방법"><a href="#방어-방법" class="headerlink" title="방어 방법"></a>방어 방법</h1><h4 id="1-입력값-검증"><a href="#1-입력값-검증" class="headerlink" title="1. 입력값 검증"></a>1. 입력값 검증</h4><p>다음과 같은 특수문자 혹은 SQL 명렁문이 입력값에 포함되있는지 검증한 후 차단한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*, –, ‘, “, ?, #, (, ), ;, @, &#x3D;, *, +, union, select, drop, update, from, </span><br><span class="line">where, join, substr, user_tables, user_table_columns, </span><br><span class="line">information_schema, sysobject, table_schema, declare, dual,…</span><br></pre></td></tr></table></figure><p>유저가 클라이언트단에서 자바스크립트를 끌 수 있으니<br>클라이언트 단에서도 차단 및 서버 단에서도 차단하여 이중장치를 마련하자.<br>대부분의 경우, 입력값 검증만 해도 막을 수 있다.</p><h4 id="2-SQL-오류-발생시-오류-메세지-클라이언트-표시-금지"><a href="#2-SQL-오류-발생시-오류-메세지-클라이언트-표시-금지" class="headerlink" title="2. SQL 오류 발생시 오류 메세지 클라이언트 표시 금지"></a>2. SQL 오류 발생시 오류 메세지 클라이언트 표시 금지</h4><p>SQL 오류 메세지를 통하여 유저가 해당 DB의 구조를 알 수 있다.</p><h4 id="3-HASH-사용"><a href="#3-HASH-사용" class="headerlink" title="3. HASH 사용"></a>3. HASH 사용</h4><p>DB에 데이터 저장시 민감한 정보는 HASH를 이용해 저장한다.<br>특히 패스워드는 반드시 SHA-256 이상으로 해싱 후 저장! (하지 않을시 개인정보보호법 29조 위반이라고 한다..)</p><hr><p>출처 : <a href="https://namu.wiki/w/SQL%20injection" target="_blank" rel="noopener">나무위키</a>, <a href="http://blog.plura.io/?p=6056" target="_blank" rel="noopener">http://blog.plura.io/?p=6056</a>, <a href="https://docs.microsoft.com/ko-kr/sql/relational-databases/security/sql-injection?view=sql-server-2017" target="_blank" rel="noopener">https://docs.microsoft.com/ko-kr/sql/relational-databases/security/sql-injection?view=sql-server-2017</a>, <a href="http://asfirstalways.tistory.com/360" target="_blank" rel="noopener">http://asfirstalways.tistory.com/360</a>, <a href="http://brownbears.tistory.com/59" target="_blank" rel="noopener">http://brownbears.tistory.com/59</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XSS와 더불어 가장 흔한 보안 공격 기술인 &lt;strong&gt;SQL injection&lt;/strong&gt;에 대해서 알아보았다.&lt;/p&gt;
&lt;h1 id=&quot;SQL-injection-이란&quot;&gt;&lt;a href=&quot;#SQL-injection-이란&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="보안" scheme="https://sj602.github.io/categories/%EB%B3%B4%EC%95%88/"/>
    
    
      <category term="보안" scheme="https://sj602.github.io/tags/%EB%B3%B4%EC%95%88/"/>
    
      <category term="SQL injection" scheme="https://sj602.github.io/tags/SQL-injection/"/>
    
  </entry>
  
  <entry>
    <title>[보안] XSS(Cross Site Scription)란 무엇인가?</title>
    <link href="https://sj602.github.io/2018/07/10/what-is-xss/"/>
    <id>https://sj602.github.io/2018/07/10/what-is-xss/</id>
    <published>2018-07-10T12:32:40.000Z</published>
    <updated>2020-03-15T23:27:55.754Z</updated>
    
    <content type="html"><![CDATA[<p>웹 개발자로서 기본적으로 알아야할 지식에 대해서 포스팅을 하려고 한다.<br>그 중 기초적인 보안 기술 중 XSS에 대해서 알아보자.</p><h1 id="XSS-Cross-Site-Scripting-이란"><a href="#XSS-Cross-Site-Scripting-이란" class="headerlink" title="XSS(Cross Site Scripting)이란?"></a>XSS(Cross Site Scripting)이란?</h1><blockquote><p>SQL injection과 함께 웹 상에서 가장 기초적인 취약점 공격 방법의 일종으로,<br>악의적인 사용자가 공격하려는 사이트에 스크립트를 넣는 기법을 말한다.<br>공격에 성공하면 사이트에 접속한 사용자는 삽입된 코드를 실행하게 되며,<br>보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등의 민감한 정보를 탈취한다. - 나무위키</p></blockquote><p>웹페이지 내에 악의적인 자바스크립트 코드를 심어넣는 방법으로 공격한다.<br>예전부터 쓰이는 간단하고 전통적인 공격 방법이지만 많은 사이트들이 이 간단한 공격에 대비를 하지 않아 공격을 받는 경우가 많다.</p><p>공격/방어방식 라는 면에서 XSS(자바스크립트 이용해 공격)와 SQL Injection(쿼리를 통해 공격)은 서로 비슷하다고 볼 수 있다.</p><h1 id="공격의-방법"><a href="#공격의-방법" class="headerlink" title="공격의 방법"></a>공격의 방법</h1><ol><li><p>스크립트 태그 안에 심기</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(document.cookie)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>서버 응답 결과에 심기</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htt:&#x2F;&#x2F;www.server.com&#x2F;search&#x2F;?q&#x3D;&lt;script&gt;(document.cookie)&lt;&#x2F;script&gt;&amp;xyz</span><br></pre></td></tr></table></figure></li><li><p>링크 또는 이미지에 심기</p></li></ol><h1 id="피해-종류"><a href="#피해-종류" class="headerlink" title="피해 종류"></a>피해 종류</h1><ol><li>쿠키 정보/세션 ID 획득</li><li>시스템 관리자 권한 획득</li><li>악성코드 다운로드</li></ol><h1 id="예방-방법"><a href="#예방-방법" class="headerlink" title="예방 방법"></a>예방 방법</h1><h4 id="1-태그-문자-무효화"><a href="#1-태그-문자-무효화" class="headerlink" title="1. 태그 문자 무효화"></a>1. 태그 문자 무효화</h4><p>기본적으로 HTML 태그 안에 심어놓는걸 방지.(‘&lt;’. ‘&gt;’) 등의 태그를<br>서버에서 브라우저로 전송시 다음과 같은 문자로 인코딩해 전송한다.<br>![](./image/html tag encoding.png)</p><h4 id="2-라이브러리-이용"><a href="#2-라이브러리-이용" class="headerlink" title="2. 라이브러리 이용"></a>2. 라이브러리 이용</h4><p>일일이 개발자가 위와 같이 인코딩하는 것은 무리가 있다.<br>유명한 라이브러리를 이용하면 손쉽게 처리가 가능하다.<br>다음과 같은 라이브러리들이 있다.</p><ul><li>AntiXSS(MS에서 개발)</li><li>OWASP ESAPI(validator:입력값 필터링, encoder:출력값 인코딩/디코딩)</li><li>NAVER Lucy XSS filter</li></ul><h4 id="3-쿠키-보안-옵션-이용"><a href="#3-쿠키-보안-옵션-이용" class="headerlink" title="3. 쿠키 보안 옵션 이용"></a>3. 쿠키 보안 옵션 이용</h4><p>쿠키 생성시<br>‘보안 쿠키’ 파라미터 지정시 TLS 상에서만 사용하게 할 수 있다.<br>‘HTTP ONLY’ 파라미터 지정시 웹브라우저상에서만 사용하게 할 수 있다.<br>완전히 방어 가능한 건 아니라고 한다.</p><hr><p>출처: <a href="https://namu.wiki/w/XSS" target="_blank" rel="noopener">나무위키</a>, <a href="http://www.kisa.or.kr/uploadfile/201312/201312161355109566.pdf" target="_blank" rel="noopener">한국인터넷진흥원</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;웹 개발자로서 기본적으로 알아야할 지식에 대해서 포스팅을 하려고 한다.&lt;br&gt;그 중 기초적인 보안 기술 중 XSS에 대해서 알아보자.&lt;/p&gt;
&lt;h1 id=&quot;XSS-Cross-Site-Scripting-이란&quot;&gt;&lt;a href=&quot;#XSS-Cross-S
      
    
    </summary>
    
    
      <category term="보안" scheme="https://sj602.github.io/categories/%EB%B3%B4%EC%95%88/"/>
    
    
      <category term="보안" scheme="https://sj602.github.io/tags/%EB%B3%B4%EC%95%88/"/>
    
      <category term="XSS" scheme="https://sj602.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>[Javascript] Class에서의 Static이란?</title>
    <link href="https://sj602.github.io/2018/06/30/static-and-not-static/"/>
    <id>https://sj602.github.io/2018/06/30/static-and-not-static/</id>
    <published>2018-06-30T13:55:50.000Z</published>
    <updated>2020-04-03T12:51:18.070Z</updated>
    
    <content type="html"><![CDATA[<p>클래스의 static method는 정적 메소드라고 불리는데 이는 클래스의 인스턴스가 필요없이 호출이 가능한 메소드를 말한다.</p><p>예를 들어,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    bar() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> baz() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>라는 코드가 있을때 bar()는</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line">f.bar();</span><br></pre></td></tr></table></figure><p>위 예시처럼 f라는 Foo의 인스턴스를 선언을 하고 그 인스턴스에서 호출을 해야하지만</p><p>baz()는</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo.baz();</span><br></pre></td></tr></table></figure><p>위 예시처럼 클래스 Foo에서 바로 호출이 가능하다.<br>Foo의 인스턴스를 선언하지 않고도 메소드를 호출이 가능하다는 것이다.</p><p>용어의 반대 관계는 아래와 같다.</p><p>** static method != instance method **</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;클래스의 static method는 정적 메소드라고 불리는데 이는 클래스의 인스턴스가 필요없이 호출이 가능한 메소드를 말한다.&lt;/p&gt;
&lt;p&gt;예를 들어,&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://sj602.github.io/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://sj602.github.io/tags/javascript/"/>
    
      <category term="static" scheme="https://sj602.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>블로그를 시작하다</title>
    <link href="https://sj602.github.io/2018/06/27/start-blog/"/>
    <id>https://sj602.github.io/2018/06/27/start-blog/</id>
    <published>2018-06-27T12:33:13.000Z</published>
    <updated>2020-03-15T23:27:55.754Z</updated>
    
    <content type="html"><![CDATA[<p>개발자로서의 첫 걸음에 앞서 블로그를 시작한다.</p><p>이 블로그는 주로 내가 학습한 개발과 관련된 내용들이 주를 이룰 것이지만</p><p>비단 개발 분야만이 아니라 좀 더 멋진 미래를 위해 하루하루 발전해나가는 내 모습을 기록할 것이다.</p><p>평소 뭔가 기록을 남겨서 머릿속에 있는 생각이든, 공부한 내용이든 정리할 필요성을 느끼고 있었고</p><p>특히나 <a href="https://hyunseob.github.io/2017/02/26/blog-for-developers/" target="_blank" rel="noopener">개발자로서 블로그 운영의 중요성</a>을 보면서</p><p>당장 시작해야겠다는 생각이 들었다. 군생활도 얼마 안남은 김에 어제밤에 Hexo로 정적 사이트 생성기로 만들어봤다. </p><p>이거 하나 만드는 데에도 굉장히 시간이 많이 걸렸는데 만드면서도 그 뭔가 모를 재미를 느꼈었다. </p><p>아마 이 감정(Craftmanship라나 뭐라더나) 때문에 수 많은 개발자들이 개발을 시작했고 또 즐기는 이유일 것이다.</p><p>블로그 제목(Jinco the Snorkel)은 요즘 하고 있는 것 중 동기들과 하고있는 스노클이라는 조직에서 내가 많은 영향을 받았고</p><p>인생의 전환기에서 “항상 스노클의 정체성을 기억하자” 라는 의미를 담았다.</p><p>나를 본격적으로 개발자의 길로 이끌었던 <a href="https://brunch.co.kr/@imagineer#articles" target="_blank" rel="noopener">마르코</a>님을 보면서</p><p>자기만의 브랜드가 중요한 시대라고 느꼈다. 아마 15년 말부터 마르코님의 브런치 글을 읽기 시작했는데</p><p>초기부터 글을 읽어온 독자로서 3년 동안 마르코님은 엄청나게 성장하신 것 같다.</p><p>아마 그 이유는 여러가지가 있었겠지만 개발이든 사업구상이든 독서든 브런치 글 발행이든 </p><p><U><em>무엇인가를 꾸준하게 하는 것</em></U>에 있을 것이다.</p><p>이제 마르코라는 이름은 &lt;비전공 문과 출신 개발자&gt;라는 분야에서 어느 정도 브랜드화 되지 않았나싶다.</p><p>마르코님은 날 모르시겠지만 개인적으로도 나의 롤모델이라고 생각하고 있다.</p><p>이 블로그를 통해 비록 지금은 내세울 것 하나 없는 사람이지만 마르코님처럼 나만의 브랜드를 쌓아나갈 것이다.</p><p>또, 개인적으로 논리력이 많이 부족하다고 생각하는데 글을 쓰면서 논리력과 타인에게 나를 표현할 수 있는 자기표현력도 많이 향상되었으면 좋겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;개발자로서의 첫 걸음에 앞서 블로그를 시작한다.&lt;/p&gt;
&lt;p&gt;이 블로그는 주로 내가 학습한 개발과 관련된 내용들이 주를 이룰 것이지만&lt;/p&gt;
&lt;p&gt;비단 개발 분야만이 아니라 좀 더 멋진 미래를 위해 하루하루 발전해나가는 내 모습을 기록할 것이다.
      
    
    </summary>
    
    
      <category term="Monologue" scheme="https://sj602.github.io/categories/Monologue/"/>
    
    
  </entry>
  
</feed>
